{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\nWelcome to the Terraform & Ansible Introduction lab!\n\n\nIn this lab we will deploy a VM-Series firewall in \nGoogle Cloud Platform\n (GCP) using Terraform.  Once deployed, we will then use \nTerraform\n and \nAnsible\n to manage the configuration of the firewall.  This will include hands-on definition of Terraform plans and Ansible playbooks while exploring the functionality of the Palo Alto Networks Ansible modules and Terraform provider.\n\n\nThe following are NOT goals of this lab:\n\n\n\n\n\n\nShow a realistic deployment of the firewall:\n More realistic deployment would only complicate the provisioning configuration. If you want to see a more realistic deployment of the firewall in GCP, then please refer to the links at the end of this document for examples.\n\n\n\n\n\n\nTeach Google Cloud Platform (GCP) functionality:\n The choice to use GCP for this lab was intended to provide exposure to GCP and its command line utilities.  However, a comprehensive overview of GCP is beyond the scope of this lab.  Many of the concept we'll briefly cover are similar to other public cloud providers.\n\n\n\n\n\n\nRequirements\n\n\n\n\nA laptop with Internet connectivity\n\n\nA standards-compliant web browser (Google Chrome, Apple Safari, or Mozilla Firefox)\n\n\nProficiency with a Linux text editor (e.g., vim, nano, emacs, etc.)\n\n\n\n\nAbout This Lab\n\n\n\n\nQwiklabs:\n This lab is launched using Qwiklabs, which is an online learning environment that provides access to the actual environment you want to learn about, not a simulation or demo environment. Qwiklabs will establish a temporary account in Google Cloud Platform and create a new GCP project to use.  However, this lab may also be used outside of Qwiklabs if you have a have a \nGCP account\n.\n\n\nGoogle Cloud Shell:\n This lab makes use of the Google Cloud Shell instead of deploying a separate VM hosting the Terraform and Ansible packages. Cloud Shell is an interactive shell environment for Google Cloud Platform. It makes it easy for you to manage your projects and resources without having to install the Google Cloud SDK and other tools on a separate host. With Cloud Shell, the Cloud SDK gcloud command-line tool and other utilities you need are always available when you need them.",
            "title": "Introduction"
        },
        {
            "location": "/#introduction",
            "text": "Welcome to the Terraform & Ansible Introduction lab!  In this lab we will deploy a VM-Series firewall in  Google Cloud Platform  (GCP) using Terraform.  Once deployed, we will then use  Terraform  and  Ansible  to manage the configuration of the firewall.  This will include hands-on definition of Terraform plans and Ansible playbooks while exploring the functionality of the Palo Alto Networks Ansible modules and Terraform provider.  The following are NOT goals of this lab:    Show a realistic deployment of the firewall:  More realistic deployment would only complicate the provisioning configuration. If you want to see a more realistic deployment of the firewall in GCP, then please refer to the links at the end of this document for examples.    Teach Google Cloud Platform (GCP) functionality:  The choice to use GCP for this lab was intended to provide exposure to GCP and its command line utilities.  However, a comprehensive overview of GCP is beyond the scope of this lab.  Many of the concept we'll briefly cover are similar to other public cloud providers.",
            "title": "Introduction"
        },
        {
            "location": "/#requirements",
            "text": "A laptop with Internet connectivity  A standards-compliant web browser (Google Chrome, Apple Safari, or Mozilla Firefox)  Proficiency with a Linux text editor (e.g., vim, nano, emacs, etc.)",
            "title": "Requirements"
        },
        {
            "location": "/#about-this-lab",
            "text": "Qwiklabs:  This lab is launched using Qwiklabs, which is an online learning environment that provides access to the actual environment you want to learn about, not a simulation or demo environment. Qwiklabs will establish a temporary account in Google Cloud Platform and create a new GCP project to use.  However, this lab may also be used outside of Qwiklabs if you have a have a  GCP account .  Google Cloud Shell:  This lab makes use of the Google Cloud Shell instead of deploying a separate VM hosting the Terraform and Ansible packages. Cloud Shell is an interactive shell environment for Google Cloud Platform. It makes it easy for you to manage your projects and resources without having to install the Google Cloud SDK and other tools on a separate host. With Cloud Shell, the Cloud SDK gcloud command-line tool and other utilities you need are always available when you need them.",
            "title": "About This Lab"
        },
        {
            "location": "/getting-started/",
            "text": "Getting Started\n\n\n\n\n\n\nLog into Qwiklabs portal for SKO19\n\n\n\n\n\n\nLaunch the Terraform & Ansible Automation lab environment",
            "title": "Getting Started"
        },
        {
            "location": "/getting-started/#getting-started",
            "text": "Log into Qwiklabs portal for SKO19    Launch the Terraform & Ansible Automation lab environment",
            "title": "Getting Started"
        },
        {
            "location": "/configuration/",
            "text": "Configuration\n\n\n\n\n\n\nLog into the GCP console at https://console.cloud.google.com\n\n\n\n\n\n\nActivate Google Cloud Shell. Use Cloud Shell because the Google Cloud SDK (gcloud) and other tools are included.\n\n\n\n\n\n\nPerform the initial lab setup\n\n\n$ git clone https://github.com/PaloAltoNetworks/terraform_ansible_intro\n$ cd sko19-automation-lab\n$ ./labconfig.sh\n$ export PATH=$HOME/bin:$PATH\n\n\n\n\n\n\n\nSet the gcloud config to the correct project (from Qwiklabs portal).\n\n\n$ gcloud projects list\n$ gcloud config set project <PROJECT>\n\n\n\n\n\n\n\nEnable the Compute Engine API\n\n\ngcloud services enable compute.googleapis.com\n\n\n\n\n\n\n\nDownload the credentials file for the Compute Engine default service account\n\n\n$ gcloud iam service-accounts list\n$ gcloud iam service-accounts keys create gcp_compute_key.json --iam-account <COMPUTE_ENGINE_EMAIL_ADDRESS>\n\n\n\n\n\n\n\nConfigure SSH key pair\n\n\n$ ssh-keygen -t rsa -b 1024 -N '' -f ~/.ssh/sko19_ssh_key\n$ chmod 400 ~/.ssh/sko19_ssh_key\n$ gcloud compute config-ssh --ssh-key-file=~/.ssh/sko19_ssh_key",
            "title": "Configuration"
        },
        {
            "location": "/configuration/#configuration",
            "text": "Log into the GCP console at https://console.cloud.google.com    Activate Google Cloud Shell. Use Cloud Shell because the Google Cloud SDK (gcloud) and other tools are included.    Perform the initial lab setup  $ git clone https://github.com/PaloAltoNetworks/terraform_ansible_intro\n$ cd sko19-automation-lab\n$ ./labconfig.sh\n$ export PATH=$HOME/bin:$PATH    Set the gcloud config to the correct project (from Qwiklabs portal).  $ gcloud projects list\n$ gcloud config set project <PROJECT>    Enable the Compute Engine API  gcloud services enable compute.googleapis.com    Download the credentials file for the Compute Engine default service account  $ gcloud iam service-accounts list\n$ gcloud iam service-accounts keys create gcp_compute_key.json --iam-account <COMPUTE_ENGINE_EMAIL_ADDRESS>    Configure SSH key pair  $ ssh-keygen -t rsa -b 1024 -N '' -f ~/.ssh/sko19_ssh_key\n$ chmod 400 ~/.ssh/sko19_ssh_key\n$ gcloud compute config-ssh --ssh-key-file=~/.ssh/sko19_ssh_key",
            "title": "Configuration"
        },
        {
            "location": "/deployment/",
            "text": "Deployment\n\n\n\n\n\n\nSet the Terraform deployment variables\n\n\n$ cd deployment\n$ vim gcp_variables.tf\n\n\n\n\n\n\n\nInitialize the Terraform providers\n\n\n$ terraform init\n\n\n\n\n\n\n\nBegin the Terraform deployment\n\n\n$ terraform plan\n$ terraform apply\n\n\n\n\n\n\n\nSet the firewall administrator password\n\n\nadmin> ssh admin@<ADDRESS>\nadmin\\# configure\nadmin\\# set mgt-config users admin password\nadmin\\# set password\nadmin\\# commit\nadmin\\# exit\nadmin> exit",
            "title": "Deployment"
        },
        {
            "location": "/deployment/#deployment",
            "text": "Set the Terraform deployment variables  $ cd deployment\n$ vim gcp_variables.tf    Initialize the Terraform providers  $ terraform init    Begin the Terraform deployment  $ terraform plan\n$ terraform apply    Set the firewall administrator password  admin> ssh admin@<ADDRESS>\nadmin\\# configure\nadmin\\# set mgt-config users admin password\nadmin\\# set password\nadmin\\# commit\nadmin\\# exit\nadmin> exit",
            "title": "Deployment"
        },
        {
            "location": "/terraform-background/",
            "text": "Terraform Background\n\n\nTerraform At a Glance\n\n\n\n\nCompany:  \nHashiCorp\n\n\nIntegration FCS: January 2018\n\n\nConfiguration: HCL (HashiCorp Configuration Language)\n\n\nDocumentation\n\n\nGitHub Repo\n\n\nImplementation Language: golang\n\n\n\n\nConfiguration Overview\n\n\nMany Files, One Configuration\n\n\nTerraform allows you to split your configuration into as many files as you\nwish.  Any Terraform file in the current working directory will be loaded and\nconcatenated with the others when you tell Terraform to apply your desired\nconfiguration.\n\n\nLocal State\n\n\nTerraform saves the things it has done to a local file, referred to as a\n\"state file\".  Because state is saved locally, that means that sometimes the\nlocal state will differ from what's actually configured on the firewall.\n\n\nThis is actually not a big deal, as many of Terraform's commands do a Read\noperation to check the actual state against what's saved locally.  Any\nchanges that are found are then saved to the local state automatically.\n\n\nExample Terraform Configuration\n\n\nHere's an example of a Terraform configuration file.  We will discuss the\nparts of this config below.\n\n\nvariable \"hostname\" {\n    default = \"127.0.0.1\"\n}\n\nvariable \"username\" {\n    default = \"admin\"\n}\n\nvariable \"password\" {\n    default = \"admin\"\n}\n\nprovider \"panos\" {\n    hostname = \"${var.hostname}\"\n    username = \"${var.username}\"\n    password = \"${var.password}\"\n}\n\nresource \"panos_management_profile\" \"ssh\" {\n    name = \"allow ssh\"\n    ssh = true\n}\n\nresource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    management_profile = \"${panos_management_profile.ssh.name}\"\n}\n\nresource \"panos_zone\" \"zone1\" {\n    name = \"L3-in\"\n    mode = \"layer3\"\n    interfaces = [\"ethernet1/1\"]\n    depends_on = [\"panos_ethernet_interface.eth1\"]\n}\n\n\n\n\nTerminology\n\n\nPlan\n\n\nA Terraform \nplan\n is the sum of all Terraform configuration files\nin a given directory.  These files are generally written in \nHCL\n.\n\n\nProvider\n\n\nA \nprovider\n can loosely thought of to be a product (such as the Palo Alto \nNetworks firewall) or a service (such as AWS, Azure, or GCP).  The provider \nunderstands the underlying API to the product or service, making individual \nparts of those things available as \nresources\n.\n\n\nMost providers require some kind of configuration in order to use.  For the\n\npanos\n provider, this is the authentication credentials of the firewall or\nPanorama that you want to configure.\n\n\nProviders are configured in a provider configuration block (e.g. -\n\nprovider \"panos\" {...}\n, and a plan can make use of any number of providers,\nall working together.\n\n\nResource\n\n\nA \nresource\n is an individual component that a provider supports \ncreate/read/update/delete operations for.\n\n\nFor the Palo Alto Networks firewall, this would be something like\nan ethernet interface, service object, or an interface management profile.\n\n\nData Source\n\n\nA \ndata source\n is like a resource, but read-only.\n\n\nFor example, the \npanos\n provider has\n\na data source\n\nthat gives you access to the results of \nshow system info\n.\n\n\nAttribute\n\n\nAn \nattribute\n is a single parameter that exists in either a resource or a \ndata source.  Individual attributes are specific to the resource itself, as to \nwhat type it is, if it's required or optional, has a default value, or if \nchanging it would require the whole resource to be recreated or not.\n\n\nAttributes can have a few different types:\n\n\n\n\nString\n:  \n\"foo\"\n, \n\"bar\"\n\n\nNumber\n: \n7\n, \n\"42\"\n (quoting numbers is fine in HCL)\n\n\nList\n: \n[\"item1\", \"item2\"]\n\n\nBoolean\n: \ntrue\n, \nfalse\n\n\nMap\n: \n{\"key\": \"value\"}\n (\nNote\n: some maps may have more complex values)\n\n\n\n\nVariables\n\n\nTerraform plans can have \nvariables\n to allow for more flexibility.  These \nvariables come in two flavors:  user variables and attribute variables.\n\nWhenever you want to use variables (or any other Terraform interpolation), \nyou'll be enclosing it in curly braces with a leading dollar sign:  \n\"${...}\"\n\n\nUser variables are variables that are defined in the Terraform plan file\nwith the \nvariable\n keyword.  These can be any of the types of values that\nattributes can be (default is string), and can also be configured to have\ndefault values.  When using a user variable in your plan files, they are\nreferenced with \nvar\n as a prefix: \n\"${var.hostname}\"\n.  Terraform looks for\nlocal variable values in the file \nterraform.tfvars\n.\n\n\nAttribute variables are variables that reference other resources or data\nsources within the same plan.  Specifying a resource attribute using an\nattribute variable creates an implicit dependency, covered below.\n\n\nDependencies\n\n\nThere are two ways to tell Terraform that resource \"A\" needs to be created\nbefore resource \"B\":  the universal \ndepends_on\n resource parameter or an\nattribute variable.  The first way, using \ndepends_on\n, is performed by\nadding the universal parameter \"depends_on\" within the dependent\nresource.  The second way, using attribute variables, is performed by\nreferencing a resource or data source attribute as a variable:\n\n\"${panos_management_profile.ssh.name}\"\n\n\nCommon Commands\n\n\nThe Terraform binary has many different CLI arguments that it supports.  We'll\ndiscuss only a few of them here:\n\n\n$ terraform init\n\n\n\n\nterraform init\n initializes the current directory based off of the local plan files, \ndownloading any missing provider binaries.\n\n\n$ terraform plan\n\n\n\n\nterraform plan\n refreshes provider/resource states and reports what changes \nneed to take place.\n\n\n$ terraform apply\n\n\n\n\nterraform apply\n refreshes provider/resource states and makes any needed \nchanges to the resources.\n\n\n$ terraform destroy\n\n\n\n\nterraform destroy\n refreshes provider/resource states and removes all \nresources that Terraform created.",
            "title": "Background"
        },
        {
            "location": "/terraform-background/#terraform-background",
            "text": "",
            "title": "Terraform Background"
        },
        {
            "location": "/terraform-background/#terraform-at-a-glance",
            "text": "Company:   HashiCorp  Integration FCS: January 2018  Configuration: HCL (HashiCorp Configuration Language)  Documentation  GitHub Repo  Implementation Language: golang",
            "title": "Terraform At a Glance"
        },
        {
            "location": "/terraform-background/#configuration-overview",
            "text": "",
            "title": "Configuration Overview"
        },
        {
            "location": "/terraform-background/#many-files-one-configuration",
            "text": "Terraform allows you to split your configuration into as many files as you\nwish.  Any Terraform file in the current working directory will be loaded and\nconcatenated with the others when you tell Terraform to apply your desired\nconfiguration.",
            "title": "Many Files, One Configuration"
        },
        {
            "location": "/terraform-background/#local-state",
            "text": "Terraform saves the things it has done to a local file, referred to as a\n\"state file\".  Because state is saved locally, that means that sometimes the\nlocal state will differ from what's actually configured on the firewall.  This is actually not a big deal, as many of Terraform's commands do a Read\noperation to check the actual state against what's saved locally.  Any\nchanges that are found are then saved to the local state automatically.",
            "title": "Local State"
        },
        {
            "location": "/terraform-background/#example-terraform-configuration",
            "text": "Here's an example of a Terraform configuration file.  We will discuss the\nparts of this config below.  variable \"hostname\" {\n    default = \"127.0.0.1\"\n}\n\nvariable \"username\" {\n    default = \"admin\"\n}\n\nvariable \"password\" {\n    default = \"admin\"\n}\n\nprovider \"panos\" {\n    hostname = \"${var.hostname}\"\n    username = \"${var.username}\"\n    password = \"${var.password}\"\n}\n\nresource \"panos_management_profile\" \"ssh\" {\n    name = \"allow ssh\"\n    ssh = true\n}\n\nresource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    management_profile = \"${panos_management_profile.ssh.name}\"\n}\n\nresource \"panos_zone\" \"zone1\" {\n    name = \"L3-in\"\n    mode = \"layer3\"\n    interfaces = [\"ethernet1/1\"]\n    depends_on = [\"panos_ethernet_interface.eth1\"]\n}",
            "title": "Example Terraform Configuration"
        },
        {
            "location": "/terraform-background/#terminology",
            "text": "",
            "title": "Terminology"
        },
        {
            "location": "/terraform-background/#plan",
            "text": "A Terraform  plan  is the sum of all Terraform configuration files\nin a given directory.  These files are generally written in  HCL .",
            "title": "Plan"
        },
        {
            "location": "/terraform-background/#provider",
            "text": "A  provider  can loosely thought of to be a product (such as the Palo Alto \nNetworks firewall) or a service (such as AWS, Azure, or GCP).  The provider \nunderstands the underlying API to the product or service, making individual \nparts of those things available as  resources .  Most providers require some kind of configuration in order to use.  For the panos  provider, this is the authentication credentials of the firewall or\nPanorama that you want to configure.  Providers are configured in a provider configuration block (e.g. - provider \"panos\" {...} , and a plan can make use of any number of providers,\nall working together.",
            "title": "Provider"
        },
        {
            "location": "/terraform-background/#resource",
            "text": "A  resource  is an individual component that a provider supports \ncreate/read/update/delete operations for.  For the Palo Alto Networks firewall, this would be something like\nan ethernet interface, service object, or an interface management profile.",
            "title": "Resource"
        },
        {
            "location": "/terraform-background/#data-source",
            "text": "A  data source  is like a resource, but read-only.  For example, the  panos  provider has a data source \nthat gives you access to the results of  show system info .",
            "title": "Data Source"
        },
        {
            "location": "/terraform-background/#attribute",
            "text": "An  attribute  is a single parameter that exists in either a resource or a \ndata source.  Individual attributes are specific to the resource itself, as to \nwhat type it is, if it's required or optional, has a default value, or if \nchanging it would require the whole resource to be recreated or not.  Attributes can have a few different types:   String :   \"foo\" ,  \"bar\"  Number :  7 ,  \"42\"  (quoting numbers is fine in HCL)  List :  [\"item1\", \"item2\"]  Boolean :  true ,  false  Map :  {\"key\": \"value\"}  ( Note : some maps may have more complex values)",
            "title": "Attribute"
        },
        {
            "location": "/terraform-background/#variables",
            "text": "Terraform plans can have  variables  to allow for more flexibility.  These \nvariables come in two flavors:  user variables and attribute variables. \nWhenever you want to use variables (or any other Terraform interpolation), \nyou'll be enclosing it in curly braces with a leading dollar sign:   \"${...}\"  User variables are variables that are defined in the Terraform plan file\nwith the  variable  keyword.  These can be any of the types of values that\nattributes can be (default is string), and can also be configured to have\ndefault values.  When using a user variable in your plan files, they are\nreferenced with  var  as a prefix:  \"${var.hostname}\" .  Terraform looks for\nlocal variable values in the file  terraform.tfvars .  Attribute variables are variables that reference other resources or data\nsources within the same plan.  Specifying a resource attribute using an\nattribute variable creates an implicit dependency, covered below.",
            "title": "Variables"
        },
        {
            "location": "/terraform-background/#dependencies",
            "text": "There are two ways to tell Terraform that resource \"A\" needs to be created\nbefore resource \"B\":  the universal  depends_on  resource parameter or an\nattribute variable.  The first way, using  depends_on , is performed by\nadding the universal parameter \"depends_on\" within the dependent\nresource.  The second way, using attribute variables, is performed by\nreferencing a resource or data source attribute as a variable: \"${panos_management_profile.ssh.name}\"",
            "title": "Dependencies"
        },
        {
            "location": "/terraform-background/#common-commands",
            "text": "The Terraform binary has many different CLI arguments that it supports.  We'll\ndiscuss only a few of them here:  $ terraform init  terraform init  initializes the current directory based off of the local plan files, \ndownloading any missing provider binaries.  $ terraform plan  terraform plan  refreshes provider/resource states and reports what changes \nneed to take place.  $ terraform apply  terraform apply  refreshes provider/resource states and makes any needed \nchanges to the resources.  $ terraform destroy  terraform destroy  refreshes provider/resource states and removes all \nresources that Terraform created.",
            "title": "Common Commands"
        },
        {
            "location": "/terraform-lab/",
            "text": "Terraform Lab Activities\n\n\nTask 1 - Basic Networking Config\n\n\nCreate a new empty directory called \nterraform-lab\n to work in.  We'll use it\nfor all of our Terraform files.\n\n\nOpen a text editor like \nvim\n, \nemacs\n, or \nnano\n and create the file\n\nsko2019.tf\n.  We will place our Terraform plan in here.\n\n\nStart by defining the provider config, which will use the \npanos\n provider.\nReplace the IP address used in \nhostname\n with the address of your lab\nfirewall, and change the \nusername\n and \npassword\n fields to the values\nyou have used.\n\n\nprovider \"panos\" {\n    hostname = \"127.0.0.1\"\n    username = \"admin\"\n    password = \"admin\"\n}\n\n\n\n\nNetwork Interfaces\n\n\nNext, create the interfaces.  Here are screenshots of the interfaces we need to\ncreate:\n\n\n\n\n\n\nAdd the following configuration to \nsko2019.tf\n.  Note that the \nethernet1/2\n\ninterface omits the option to create the default route via DHCP.\n\n\nresource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    create_dhcp_default_route = true\n}\n\nresource \"panos_ethernet_interface\" \"eth2\" {\n    name = \"ethernet1/2\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n}\n\n\n\n\nRefer to the \nprovider\ndocumentation\n\nfor ethernet interfaces for more info if you need.\n\n\nZones\n\n\nNext, create zones for the interfaces we just added.  Here are screenshots of\nthe zones we need to create:\n\n\n\n\n\n\nAdd the following configuration to \nsko2019.tf\n.  The interfaces are referenced\nby name, so that Terraform automatically knows that the interfaces need to be\ncreated before the zones themselves.\n\n\nresource \"panos_zone\" \"int\" {\n    name = \"L3-trust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth1.name}\"]\n}\n\nresource \"panos_zone\" \"ext\" {\n    name = \"L3-untrust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth2.name}\"]\n}\n\n\n\n\nRefer to the \nprovider\ndocumentation\n for\nzones if you need.\n\n\nApply the Terraform Plan\n\n\nYour final, full \nsko2019.tf\n file should look something like this:\n\n\nprovider \"panos\" {\n    hostname = \"127.0.0.1\"\n    username = \"admin\"\n    password = \"admin\"\n}\n\nresource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    create_dhcp_default_route = true\n}\n\nresource \"panos_ethernet_interface\" \"eth2\" {\n    name = \"ethernet1/2\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n}\n\nresource \"panos_zone\" \"int\" {\n    name = \"L3-trust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth1.name}\"]\n}\n\nresource \"panos_zone\" \"ext\" {\n    name = \"L3-untrust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth2.name}\"]\n}\n\n\n\n\nLet's apply the config to our firewall.  You need to run \nterraform init\n first\nto download all the providers we need, and then check your config with\n\nterraform plan\n:\n\n\n$ terraform init\n$ terraform plan\n\n\n\n\nIf there are no errors, go ahead and push your config updates the firewall:\n\n\n$ terraform apply\n\n\n\n\nLog in to the GUI of your firewall and verify that the configuration matches\nwhat you want.  Note that because of the way Terraform currently functions, the\nchanges have only been made to the candidate configuration and have \nnot\n\nbeen committed.\n\n\n\n\nTask 2 - Objects and Security Rule Creation\n\n\nNext, we will create an address object and some security rules.\n\n\nHere is a screenshot of an address object we need to create:\n\n\n\n\nAdd the following to \nsko2019.tf\n:\n\n\nresource \"panos_address_object\" \"wp\" {\n    name = \"wordpress server\"\n    description = \"Internal server\"\n    value = \"10.1.23.45\"\n}\n\n\n\n\nRefer to the \nprovider\ndocumentation\n\nfor address objects if you need.\n\n\nNow, here is a screenshot of security rules that we need to create:\n\n\n\n\nAdd the following to \nsko2019.tf\n.  Just like with the networking config, zones\nand objects are referenced by name, so that Terraform knows they need to be\ncreated before our security rules.\n\n\nresource \"panos_security_rule_group\" \"policy\" {\n    rule {\n        name = \"Wordpress Traffic\"\n        source_zones = [\"${panos_zone.ext.name}\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"${panos_zone.int.name}\"]\n        destination_addresses = [\"any\"]\n        applications = [\"web-browsing\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"allow\"\n    }\n    rule {\n        name = \"Outbound\"\n        source_zones = [\"${panos_zone.int.name}\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"${panos_zone.ext.name}\"]\n        destination_addresses = [\"any\"]\n        applications = [\"any\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"allow\"\n    }\n    rule {\n        name = \"Default Deny\"\n        source_zones = [\"any\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"any\"]\n        destination_addresses = [\"any\"]\n        applications = [\"any\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"deny\"\n    }\n}\n\n\n\n\nApply the Terraform Plan\n\n\nLet's apply the config to our firewall.  We don't need to run \nterraform init\n\nagain, so just check your config with \nterraform plan\n:\n\n\n$ terraform plan\n\n\n\n\nIf there are no errors, go ahead and push your config updates the firewall:\n\n\n$ terraform apply\n\n\n\n\nLog in to the GUI of your firewall and verify that the configuration matches\nwhat you want.  Again, the changes have only been made to the candidate\nconfiguration and have \nnot\n been committed.\n\n\n\n\nTask 3 - Cleanup\n\n\nTerraform will clean up our config for us with the \nterraform destroy\n command.\nRun it to prepare for the Ansible portion of the lab:\n\n\n$ terraform destroy\n\n\n\n\nYou're done with the Terraform portion of the lab.",
            "title": "Lab Activities"
        },
        {
            "location": "/terraform-lab/#terraform-lab-activities",
            "text": "",
            "title": "Terraform Lab Activities"
        },
        {
            "location": "/terraform-lab/#task-1-basic-networking-config",
            "text": "Create a new empty directory called  terraform-lab  to work in.  We'll use it\nfor all of our Terraform files.  Open a text editor like  vim ,  emacs , or  nano  and create the file sko2019.tf .  We will place our Terraform plan in here.  Start by defining the provider config, which will use the  panos  provider.\nReplace the IP address used in  hostname  with the address of your lab\nfirewall, and change the  username  and  password  fields to the values\nyou have used.  provider \"panos\" {\n    hostname = \"127.0.0.1\"\n    username = \"admin\"\n    password = \"admin\"\n}",
            "title": "Task 1 - Basic Networking Config"
        },
        {
            "location": "/terraform-lab/#network-interfaces",
            "text": "Next, create the interfaces.  Here are screenshots of the interfaces we need to\ncreate:    Add the following configuration to  sko2019.tf .  Note that the  ethernet1/2 \ninterface omits the option to create the default route via DHCP.  resource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    create_dhcp_default_route = true\n}\n\nresource \"panos_ethernet_interface\" \"eth2\" {\n    name = \"ethernet1/2\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n}  Refer to the  provider\ndocumentation \nfor ethernet interfaces for more info if you need.",
            "title": "Network Interfaces"
        },
        {
            "location": "/terraform-lab/#zones",
            "text": "Next, create zones for the interfaces we just added.  Here are screenshots of\nthe zones we need to create:    Add the following configuration to  sko2019.tf .  The interfaces are referenced\nby name, so that Terraform automatically knows that the interfaces need to be\ncreated before the zones themselves.  resource \"panos_zone\" \"int\" {\n    name = \"L3-trust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth1.name}\"]\n}\n\nresource \"panos_zone\" \"ext\" {\n    name = \"L3-untrust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth2.name}\"]\n}  Refer to the  provider\ndocumentation  for\nzones if you need.",
            "title": "Zones"
        },
        {
            "location": "/terraform-lab/#apply-the-terraform-plan",
            "text": "Your final, full  sko2019.tf  file should look something like this:  provider \"panos\" {\n    hostname = \"127.0.0.1\"\n    username = \"admin\"\n    password = \"admin\"\n}\n\nresource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    create_dhcp_default_route = true\n}\n\nresource \"panos_ethernet_interface\" \"eth2\" {\n    name = \"ethernet1/2\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n}\n\nresource \"panos_zone\" \"int\" {\n    name = \"L3-trust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth1.name}\"]\n}\n\nresource \"panos_zone\" \"ext\" {\n    name = \"L3-untrust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth2.name}\"]\n}  Let's apply the config to our firewall.  You need to run  terraform init  first\nto download all the providers we need, and then check your config with terraform plan :  $ terraform init\n$ terraform plan  If there are no errors, go ahead and push your config updates the firewall:  $ terraform apply  Log in to the GUI of your firewall and verify that the configuration matches\nwhat you want.  Note that because of the way Terraform currently functions, the\nchanges have only been made to the candidate configuration and have  not \nbeen committed.",
            "title": "Apply the Terraform Plan"
        },
        {
            "location": "/terraform-lab/#task-2-objects-and-security-rule-creation",
            "text": "Next, we will create an address object and some security rules.  Here is a screenshot of an address object we need to create:   Add the following to  sko2019.tf :  resource \"panos_address_object\" \"wp\" {\n    name = \"wordpress server\"\n    description = \"Internal server\"\n    value = \"10.1.23.45\"\n}  Refer to the  provider\ndocumentation \nfor address objects if you need.  Now, here is a screenshot of security rules that we need to create:   Add the following to  sko2019.tf .  Just like with the networking config, zones\nand objects are referenced by name, so that Terraform knows they need to be\ncreated before our security rules.  resource \"panos_security_rule_group\" \"policy\" {\n    rule {\n        name = \"Wordpress Traffic\"\n        source_zones = [\"${panos_zone.ext.name}\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"${panos_zone.int.name}\"]\n        destination_addresses = [\"any\"]\n        applications = [\"web-browsing\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"allow\"\n    }\n    rule {\n        name = \"Outbound\"\n        source_zones = [\"${panos_zone.int.name}\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"${panos_zone.ext.name}\"]\n        destination_addresses = [\"any\"]\n        applications = [\"any\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"allow\"\n    }\n    rule {\n        name = \"Default Deny\"\n        source_zones = [\"any\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"any\"]\n        destination_addresses = [\"any\"]\n        applications = [\"any\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"deny\"\n    }\n}",
            "title": "Task 2 - Objects and Security Rule Creation"
        },
        {
            "location": "/terraform-lab/#apply-the-terraform-plan_1",
            "text": "Let's apply the config to our firewall.  We don't need to run  terraform init \nagain, so just check your config with  terraform plan :  $ terraform plan  If there are no errors, go ahead and push your config updates the firewall:  $ terraform apply  Log in to the GUI of your firewall and verify that the configuration matches\nwhat you want.  Again, the changes have only been made to the candidate\nconfiguration and have  not  been committed.",
            "title": "Apply the Terraform Plan"
        },
        {
            "location": "/terraform-lab/#task-3-cleanup",
            "text": "Terraform will clean up our config for us with the  terraform destroy  command.\nRun it to prepare for the Ansible portion of the lab:  $ terraform destroy  You're done with the Terraform portion of the lab.",
            "title": "Task 3 - Cleanup"
        },
        {
            "location": "/ansible-background/",
            "text": "Ansible Background\n\n\nAnsible At a Glance\n\n\n\n\nCompany: \nRedHat\n\n\nIntegration FCS: January 2015\n\n\nConfiguration: YAML (Yet Another Markup Language)\n\n\nDocumentation\n\n\nGitHub Repo\n\n\nImplementation Language: python\n\n\n\n\nConfiguration Overview\n\n\nPlaybooks\n\n\nThough Ansible allows you to execute ad hoc commands against your desired\ninventory, the better way to use Ansible is with Ansible playbooks. \nAnsible playbooks are a list of configuration operations, or plays, to be\nperformed.  Ansible playbooks are written in YAML, which you can find out\nmore about\n\nhere\n. \nPlaybooks are run from top to bottom, which means that if one configuration\ndepends on another being present, you simply put the dependency higher in the\nplaybook.  You can even tell Ansible to run another playbook from within the\nfirst playbook by importing it in.\n\n\nNo Local State\n\n\nUnlike Terraform, Ansible does not keep a local state of what is configured.\n\n\nModules Are Use Case Focused\n\n\nAlso unlike the Terraform provider, Ansible modules tend to be more use case\nfocused as opposed to trying to be a single, atomic component controller.  The\n\npanos_interface\n\nmodule is probably the best example of this to date, as it not only creates\ninterfaces, but can also create zones, place the interface into that zone,\nthen finally put the interface into a virtual router.  That same workflow in\nTerraform would require three separate resources using dependencies.\n\n\nExample Ansible Configuration\n\n\nHere's an example of an Ansible playbook.  We will discuss the various\nparts of this below.\n\n\n- name: My Ansible Playbook\n  hosts: my-fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n  - name: \"Add interface management profile\"\n    panos_management_profile:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      name: 'allow ssh'\n      ssh: true\n      commit: false\n\n  - name: \"Configure eth1/1 and put it in zone L3-in\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      zone_name: 'L3-in'\n      commit: false\n\n\n\n\nTerminology\n\n\nHosts\n\n\nAnsible executes actions against an inventory.  If you\u2019re going to run Ansible \nin production, you\u2019ll probably want to use the inventory file to organize your \nfirewalls and Panoramas into groups to make management easier.  For the \npurposes of our lab, however, we just want to run the playbooks against a \nsingle host.  So instead of putting the host in a hosts file, we\u2019re going to \nuse variables instead.\n\n\nIf you desire, you can read more about Ansible inventory\n\nhere\n.\n\n\nConnection\n\n\nTypically Ansible will ssh to a remote machine and perform commands as the \nspecified user account.  However, we don't want this for the Palo Alto Networks \nAnsible modules, as the modules connect to our API.  Thus this should be set to \n\"local\" as we want Ansible to initiate the connection locally.\n\n\nGather Facts\n\n\nAnsible facts are just information about remote nodes.  In our case, we aren\u2019t \ngoing to use facts for anything, so we\u2019re disabling them to ensure that our \nAnsible invocations are run in a timely manner (this is would probably not be \ndisabled in production).\n\n\nIf you want to read more about facts, you can find that info\n\nhere\n.\n\n\nRoles\n\n\nLet\u2019s discuss the \"PaloAltoNetworks.paloaltonetworks\" role that our playbook \nis using.  Ansible comes with various Palo Alto Networks packages when you \n\npip install ansible\n, but updating these packages takes a lot of time and \neffort.  In an effort to get new features to customers sooner, we've made \nnewer features available as an Ansible galaxy role.  Including this role in \nour playbook means that Ansible will use the role\u2019s code (the newest released \ncode) for the Ansible plays instead of the older code that's merged upstream \nwith Ansible.\n\n\nTasks\n\n\nEach playbook contains a list of tasks to perform.  These are executed in \norder, one at a time against the inventory.  Each task will have a \"name\", \nand this name is what shows up on the CLI when executing the Ansible playbook.\nBesides the name, you will specify the module to execute, and then an \nindented list of the values you want to pass in to that module.\n\n\nKnowing what you know about tasks, let\u2019s take a look at that \"include_vars\"\ntask.  At this point, knowing what the format of tasks is, you can now\nidentify \"include_vars\" as a module invocation (documentation for\n\"include_vars\" is\n\nhere\n). \n\n\nSo what\u2019s that \nno_log\n part?  This is simply to keep the authentication\ncredentials safe without compromising the verbosity of our Ansible output. \nYou can read more about that\n\nhere\n\nin the Ansible FAQs.\n\n\nDependencies\n\n\nAs mentioned previously, if you're using Ansible playbooks, then when you\nhave dependencies, simply place those further up in the playbook.",
            "title": "Background"
        },
        {
            "location": "/ansible-background/#ansible-background",
            "text": "",
            "title": "Ansible Background"
        },
        {
            "location": "/ansible-background/#ansible-at-a-glance",
            "text": "Company:  RedHat  Integration FCS: January 2015  Configuration: YAML (Yet Another Markup Language)  Documentation  GitHub Repo  Implementation Language: python",
            "title": "Ansible At a Glance"
        },
        {
            "location": "/ansible-background/#configuration-overview",
            "text": "",
            "title": "Configuration Overview"
        },
        {
            "location": "/ansible-background/#playbooks",
            "text": "Though Ansible allows you to execute ad hoc commands against your desired\ninventory, the better way to use Ansible is with Ansible playbooks. \nAnsible playbooks are a list of configuration operations, or plays, to be\nperformed.  Ansible playbooks are written in YAML, which you can find out\nmore about here . \nPlaybooks are run from top to bottom, which means that if one configuration\ndepends on another being present, you simply put the dependency higher in the\nplaybook.  You can even tell Ansible to run another playbook from within the\nfirst playbook by importing it in.",
            "title": "Playbooks"
        },
        {
            "location": "/ansible-background/#no-local-state",
            "text": "Unlike Terraform, Ansible does not keep a local state of what is configured.",
            "title": "No Local State"
        },
        {
            "location": "/ansible-background/#modules-are-use-case-focused",
            "text": "Also unlike the Terraform provider, Ansible modules tend to be more use case\nfocused as opposed to trying to be a single, atomic component controller.  The panos_interface \nmodule is probably the best example of this to date, as it not only creates\ninterfaces, but can also create zones, place the interface into that zone,\nthen finally put the interface into a virtual router.  That same workflow in\nTerraform would require three separate resources using dependencies.",
            "title": "Modules Are Use Case Focused"
        },
        {
            "location": "/ansible-background/#example-ansible-configuration",
            "text": "Here's an example of an Ansible playbook.  We will discuss the various\nparts of this below.  - name: My Ansible Playbook\n  hosts: my-fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n  - name: \"Add interface management profile\"\n    panos_management_profile:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      name: 'allow ssh'\n      ssh: true\n      commit: false\n\n  - name: \"Configure eth1/1 and put it in zone L3-in\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      zone_name: 'L3-in'\n      commit: false",
            "title": "Example Ansible Configuration"
        },
        {
            "location": "/ansible-background/#terminology",
            "text": "",
            "title": "Terminology"
        },
        {
            "location": "/ansible-background/#hosts",
            "text": "Ansible executes actions against an inventory.  If you\u2019re going to run Ansible \nin production, you\u2019ll probably want to use the inventory file to organize your \nfirewalls and Panoramas into groups to make management easier.  For the \npurposes of our lab, however, we just want to run the playbooks against a \nsingle host.  So instead of putting the host in a hosts file, we\u2019re going to \nuse variables instead.  If you desire, you can read more about Ansible inventory here .",
            "title": "Hosts"
        },
        {
            "location": "/ansible-background/#connection",
            "text": "Typically Ansible will ssh to a remote machine and perform commands as the \nspecified user account.  However, we don't want this for the Palo Alto Networks \nAnsible modules, as the modules connect to our API.  Thus this should be set to \n\"local\" as we want Ansible to initiate the connection locally.",
            "title": "Connection"
        },
        {
            "location": "/ansible-background/#gather-facts",
            "text": "Ansible facts are just information about remote nodes.  In our case, we aren\u2019t \ngoing to use facts for anything, so we\u2019re disabling them to ensure that our \nAnsible invocations are run in a timely manner (this is would probably not be \ndisabled in production).  If you want to read more about facts, you can find that info here .",
            "title": "Gather Facts"
        },
        {
            "location": "/ansible-background/#roles",
            "text": "Let\u2019s discuss the \"PaloAltoNetworks.paloaltonetworks\" role that our playbook \nis using.  Ansible comes with various Palo Alto Networks packages when you  pip install ansible , but updating these packages takes a lot of time and \neffort.  In an effort to get new features to customers sooner, we've made \nnewer features available as an Ansible galaxy role.  Including this role in \nour playbook means that Ansible will use the role\u2019s code (the newest released \ncode) for the Ansible plays instead of the older code that's merged upstream \nwith Ansible.",
            "title": "Roles"
        },
        {
            "location": "/ansible-background/#tasks",
            "text": "Each playbook contains a list of tasks to perform.  These are executed in \norder, one at a time against the inventory.  Each task will have a \"name\", \nand this name is what shows up on the CLI when executing the Ansible playbook.\nBesides the name, you will specify the module to execute, and then an \nindented list of the values you want to pass in to that module.  Knowing what you know about tasks, let\u2019s take a look at that \"include_vars\"\ntask.  At this point, knowing what the format of tasks is, you can now\nidentify \"include_vars\" as a module invocation (documentation for\n\"include_vars\" is here ).   So what\u2019s that  no_log  part?  This is simply to keep the authentication\ncredentials safe without compromising the verbosity of our Ansible output. \nYou can read more about that here \nin the Ansible FAQs.",
            "title": "Tasks"
        },
        {
            "location": "/ansible-background/#dependencies",
            "text": "As mentioned previously, if you're using Ansible playbooks, then when you\nhave dependencies, simply place those further up in the playbook.",
            "title": "Dependencies"
        },
        {
            "location": "/ansible-lab/",
            "text": "Ansible Lab Activities\n\n\nTask 1 - Lab Setup\n\n\nCreate a new empty directory called \nansible-lab\n to work in.  We'll use it for\nall of our Ansible files.\n\n\nThen, install the Palo Alto Networks Ansible Galaxy role:\n\n\n$ sudo ansible-galaxy install PaloAltoNetworks.paloaltonetworks\n\n\n\n\n\n\nTask 2 - Basic Network Config\n\n\nOpen a text editor like \nvim\n, \nemacs\n, or \nnano\n and create the file\n\ninventory\n.  This file contains a list of hosts that Ansible will communicate\nwith during execution.\n\n\nAdd the following to the file \ninventory\n, \nreplacing\n the IP address with\nthe address of your lab firewall.\n\n\n[fw]\n127.0.0.1\n\n\n\n\nNext, create the file \nfw_creds.yml\n.  Replace the IP address used in\n\nip_address\n with the address of your lab  firewall, and change the\n\nusername\n and \npassword\n fields to the values you have used.\n\n\nip_address: '127.0.0.1'\nusername: 'admin'\npassword: 'admin'\n\n\n\n\nNow, create the file \nnetwork.yml\n.  This will be the playbook that holds the\nlow level networking config for our firewall.\n\n\nEach playbook needs the following header information to pull in the variables\nwe just defined.  Add the following to \nnetwork.yml\n:\n\n\n- name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n\n\n\nNetwork Interfaces & Zones\n\n\nWe're going to create the exact same configuration with Ansible as we did with\nTerraform.  Here are screenshots of the network interfaces and zones we need to\ncreate:\n\n\n\n\n\n\n\n\n\n\nAdd the following to \nnetwork.yml\n:\n\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n  - name: \"Configure eth1/1\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      create_default_route: true\n      zone_name: 'L3-trust'\n      commit: False\n\n  - name: \"Configure eth1/2\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/2'\n      zone_name: 'L3-untrust'\n      commit: False\n\n\n\n\nRefer to the \nmodule\ndocumentation\n\nfor ethernet interfaces if you need.\n\n\nNote that Ansible is a little different from Terraform.  We have to specify the\n\nip_address\n, \nusername\n, and \npassword\n each time because each module\nexecutes independently.  Also, we don't have to create the zones as a separate\nstep because they will be created for us if they don't exist.\n\n\nRun the Playbook\n\n\nYour final, full \nnetwork.yml\n playbook should look like this:\n\n\n- name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n  - name: \"Configure eth1/1\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      create_default_route: true\n      zone_name: 'L3-trust'\n      commit: False\n\n  - name: \"Configure eth1/2\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/2'\n      zone_name: 'L3-untrust'\n      commit: False\n\n\n\n\nRun your playbook with the following command:\n\n\n$ ansible-playbook -i inventory network.yml\n\n\n\n\nLog in to the GUI of your firewall and verify that the configuration matches\nwhat you want.  Because we specified \ncommit: False\n for each module call in\nour playbook, the changes have only been made to the candidate configuration\nand have \nnot\n been committed.\n\n\nIf you get errors, indentation is most likely the problem.  Once you fix any\nerrors, run the playbook again and the firewall should now have your desired\nconfig.\n\n\n\n\nTask 3 - Objects and Security Rule Creation\n\n\nNow we will create the same address object and security rules as in the\nTerraform portion.  Create a new file \nrules.yml\n, and copy in the header\ninformation from the network config steps:\n\n\n- name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n\n\n\nHere is the address object we need to create:\n\n\n\n\nAdd the following to \nrules.yml\n:\n\n\n  - name: \"Add address object for wordpress server\"\n    panos_object:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      addressobject: 'wordpress server'\n      address: '10.1.23.45'\n      description: 'Internal server'\n      commit: false\n\n\n\n\nRefer to the \nmodule\ndocumentation\n\nfor address objects if you need.\n\n\nHere are the security rules we need to create:\n\n\n\n\nAdd the following to \nrules.yml\n:\n\n\n  - name: \"Add Wordpress Traffic rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Wordpress Traffic'\n      source_zone: ['L3-untrust']\n      destination_zone: ['L3-trust']\n      destination_ip: ['wordpress server']\n      application: ['web-browsing']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Outbound rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Outbound'\n      source_zone: ['L3-trust']\n      destination_zone: ['L3-untrust']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Default Deny rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Default Deny'\n      action: 'deny'\n      commit: false\n\n\n\n\nRun the Playbook\n\n\nYour final, full \nrules.yml\n playbook should look like this:\n\n\n- name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n  - name: \"Add address object for wordpress server\"\n    panos_object:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      addressobject: 'wordpress server'\n      address: '10.1.23.45'\n      description: 'Internal server'\n      commit: false\n\n  - name: \"Add Wordpress Traffic rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Wordpress Traffic'\n      source_zone: ['L3-untrust']\n      destination_zone: ['L3-trust']\n      destination_ip: ['wordpress server']\n      application: ['web-browsing']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Outbound rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Outbound'\n      source_zone: ['L3-trust']\n      destination_zone: ['L3-untrust']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Default Deny rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Default Deny'\n      action: 'deny'\n      commit: false\n\n\n\n\nRun your playbook with the following command:\n\n\n$ ansible-playbook -i inventory rules.yml\n\n\n\n\nLog in to the GUI of your firewall and verify that the configuration matches\nwhat you want.  Remember that your changes haven't been committed, and if you \nget errors, indentation is most likely the problem.\n\n\nYou're done with the Ansible portion of the lab.",
            "title": "Lab Activities"
        },
        {
            "location": "/ansible-lab/#ansible-lab-activities",
            "text": "",
            "title": "Ansible Lab Activities"
        },
        {
            "location": "/ansible-lab/#task-1-lab-setup",
            "text": "Create a new empty directory called  ansible-lab  to work in.  We'll use it for\nall of our Ansible files.  Then, install the Palo Alto Networks Ansible Galaxy role:  $ sudo ansible-galaxy install PaloAltoNetworks.paloaltonetworks",
            "title": "Task 1 - Lab Setup"
        },
        {
            "location": "/ansible-lab/#task-2-basic-network-config",
            "text": "Open a text editor like  vim ,  emacs , or  nano  and create the file inventory .  This file contains a list of hosts that Ansible will communicate\nwith during execution.  Add the following to the file  inventory ,  replacing  the IP address with\nthe address of your lab firewall.  [fw]\n127.0.0.1  Next, create the file  fw_creds.yml .  Replace the IP address used in ip_address  with the address of your lab  firewall, and change the username  and  password  fields to the values you have used.  ip_address: '127.0.0.1'\nusername: 'admin'\npassword: 'admin'  Now, create the file  network.yml .  This will be the playbook that holds the\nlow level networking config for our firewall.  Each playbook needs the following header information to pull in the variables\nwe just defined.  Add the following to  network.yml :  - name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'",
            "title": "Task 2 - Basic Network Config"
        },
        {
            "location": "/ansible-lab/#network-interfaces-zones",
            "text": "We're going to create the exact same configuration with Ansible as we did with\nTerraform.  Here are screenshots of the network interfaces and zones we need to\ncreate:      Add the following to  network.yml :    tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n  - name: \"Configure eth1/1\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      create_default_route: true\n      zone_name: 'L3-trust'\n      commit: False\n\n  - name: \"Configure eth1/2\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/2'\n      zone_name: 'L3-untrust'\n      commit: False  Refer to the  module\ndocumentation \nfor ethernet interfaces if you need.  Note that Ansible is a little different from Terraform.  We have to specify the ip_address ,  username , and  password  each time because each module\nexecutes independently.  Also, we don't have to create the zones as a separate\nstep because they will be created for us if they don't exist.",
            "title": "Network Interfaces &amp; Zones"
        },
        {
            "location": "/ansible-lab/#run-the-playbook",
            "text": "Your final, full  network.yml  playbook should look like this:  - name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n  - name: \"Configure eth1/1\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      create_default_route: true\n      zone_name: 'L3-trust'\n      commit: False\n\n  - name: \"Configure eth1/2\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/2'\n      zone_name: 'L3-untrust'\n      commit: False  Run your playbook with the following command:  $ ansible-playbook -i inventory network.yml  Log in to the GUI of your firewall and verify that the configuration matches\nwhat you want.  Because we specified  commit: False  for each module call in\nour playbook, the changes have only been made to the candidate configuration\nand have  not  been committed.  If you get errors, indentation is most likely the problem.  Once you fix any\nerrors, run the playbook again and the firewall should now have your desired\nconfig.",
            "title": "Run the Playbook"
        },
        {
            "location": "/ansible-lab/#task-3-objects-and-security-rule-creation",
            "text": "Now we will create the same address object and security rules as in the\nTerraform portion.  Create a new file  rules.yml , and copy in the header\ninformation from the network config steps:  - name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'  Here is the address object we need to create:   Add the following to  rules.yml :    - name: \"Add address object for wordpress server\"\n    panos_object:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      addressobject: 'wordpress server'\n      address: '10.1.23.45'\n      description: 'Internal server'\n      commit: false  Refer to the  module\ndocumentation \nfor address objects if you need.  Here are the security rules we need to create:   Add the following to  rules.yml :    - name: \"Add Wordpress Traffic rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Wordpress Traffic'\n      source_zone: ['L3-untrust']\n      destination_zone: ['L3-trust']\n      destination_ip: ['wordpress server']\n      application: ['web-browsing']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Outbound rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Outbound'\n      source_zone: ['L3-trust']\n      destination_zone: ['L3-untrust']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Default Deny rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Default Deny'\n      action: 'deny'\n      commit: false",
            "title": "Task 3 - Objects and Security Rule Creation"
        },
        {
            "location": "/ansible-lab/#run-the-playbook_1",
            "text": "Your final, full  rules.yml  playbook should look like this:  - name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n  - name: \"Add address object for wordpress server\"\n    panos_object:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      addressobject: 'wordpress server'\n      address: '10.1.23.45'\n      description: 'Internal server'\n      commit: false\n\n  - name: \"Add Wordpress Traffic rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Wordpress Traffic'\n      source_zone: ['L3-untrust']\n      destination_zone: ['L3-trust']\n      destination_ip: ['wordpress server']\n      application: ['web-browsing']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Outbound rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Outbound'\n      source_zone: ['L3-trust']\n      destination_zone: ['L3-untrust']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Default Deny rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Default Deny'\n      action: 'deny'\n      commit: false  Run your playbook with the following command:  $ ansible-playbook -i inventory rules.yml  Log in to the GUI of your firewall and verify that the configuration matches\nwhat you want.  Remember that your changes haven't been committed, and if you \nget errors, indentation is most likely the problem.  You're done with the Ansible portion of the lab.",
            "title": "Run the Playbook"
        },
        {
            "location": "/comparison/",
            "text": "Comparing Terraform and Ansible\n\n\nAt this point, you've now used both Ansible and Terraform to configure a\nPalo Alto Networks firewall.  Though you've used these two tools to deploy\nthe same configuration, they differ in some important ways.  Let's discuss\nsome of those differences now.\n\n\nReputation\n\n\nBoth tools have a certain reputation associated with them.  Terraform is known\nmore for its power in deployment, while Ansible is known more for its\nflexibility in configuration.  Both products can do both jobs just fine.\n\n\nRegardless of their reputations, the most important part is that Palo Alto Networks\nhas integrations with both, and either way will get the job done.  It's\njust a matter of preference.\n\n\nIdempotence\n\n\nBoth Terraform and Ansible support \nidempotent\n\noperations.  Saying that an operation is idempotent means that applying it\nmultiple times will not change the result.  This is important for automation\ntools because they can be run to change configuration \nand\n also to verify\nthat the configuration actually matches what you want.  You can run\n\nterraform apply\n continuously for hours, and if your configuration matches\nwhat is defined in the plan, it won't actually change anything.\n\n\nHowever, the Palo Alto Networks Ansible modules do not currently support\nidempotent operation.  Most of the modules have an \noperation\n field which\ncan be \nadd\n, \nupdate\n or \ndelete\n.  Running the same playbook over again will\ncause a failure, because you can't add objects over top of themselves, or\ndelete ones that don't exist.  Supporting idempotent operations will be added\nto these modules in the future.\n\n\nCommits\n\n\nAs you've probably noticed, a lot of the Ansible modules allow you to commit\ndirectly from them.  There is also a dedicated Ansible module that just does\ncommits, containing support for both the firewall and Panorama.  \n\n\nSo how do you perform commits with Terraform?  Currently, there is no support\nfor commits inside the Terraform ecosystem, so they have to be handled \nexternally.  Lack of finalizers are\n\na known shortcoming\n\nfor Terraform and, once it is addressed, support for it can be added to the\nprovider.  In the mean time, we provide\n\na golang script\n\nyou can use to fill the gap.\n\n\nOperational Commands\n\n\nAnsible currently has a \npanos_op\n module allows users to run arbitrary\noperational commands.  An operational command could be something that just\nshows some part of the configuration, but it can also change configuration.\nSince Ansible doesn't store state, it doesn't care what the invocation of\nthe \npanos_op\n module results in.\n\n\nThis is a different story in Terraform.  The basic flow of Terraform is that\nthere is a read operation that determines if a create, update, or delete needs\nto take place.  But operational commands as a whole don't fit as neatly into\nthis paradigm.  What if the operational command is just a read?  What if the\noperational command makes a configuration change, and should only be executed\nonce?  This uncertainty is why support for operational commands in Terraform\nis not currently in place.\n\n\nFacts / Data Sources\n\n\nTerraform may not have support for arbitrary operational commands, but it does\nhave a data source right now that you can retrieve specific parts of\n\nshow system info\n from the firewall or Panorama and then use that in your\nplan file.\n\n\nThis same thing is called \"facts\" in Ansible.  Some of our Ansible modules have\nsupport for an additional operation, \nfind\n, that acts in some ways like this,\nbut support for this is still being investigated or developed.",
            "title": "Comparing Terraform and Ansible"
        },
        {
            "location": "/comparison/#comparing-terraform-and-ansible",
            "text": "At this point, you've now used both Ansible and Terraform to configure a\nPalo Alto Networks firewall.  Though you've used these two tools to deploy\nthe same configuration, they differ in some important ways.  Let's discuss\nsome of those differences now.",
            "title": "Comparing Terraform and Ansible"
        },
        {
            "location": "/comparison/#reputation",
            "text": "Both tools have a certain reputation associated with them.  Terraform is known\nmore for its power in deployment, while Ansible is known more for its\nflexibility in configuration.  Both products can do both jobs just fine.  Regardless of their reputations, the most important part is that Palo Alto Networks\nhas integrations with both, and either way will get the job done.  It's\njust a matter of preference.",
            "title": "Reputation"
        },
        {
            "location": "/comparison/#idempotence",
            "text": "Both Terraform and Ansible support  idempotent \noperations.  Saying that an operation is idempotent means that applying it\nmultiple times will not change the result.  This is important for automation\ntools because they can be run to change configuration  and  also to verify\nthat the configuration actually matches what you want.  You can run terraform apply  continuously for hours, and if your configuration matches\nwhat is defined in the plan, it won't actually change anything.  However, the Palo Alto Networks Ansible modules do not currently support\nidempotent operation.  Most of the modules have an  operation  field which\ncan be  add ,  update  or  delete .  Running the same playbook over again will\ncause a failure, because you can't add objects over top of themselves, or\ndelete ones that don't exist.  Supporting idempotent operations will be added\nto these modules in the future.",
            "title": "Idempotence"
        },
        {
            "location": "/comparison/#commits",
            "text": "As you've probably noticed, a lot of the Ansible modules allow you to commit\ndirectly from them.  There is also a dedicated Ansible module that just does\ncommits, containing support for both the firewall and Panorama.    So how do you perform commits with Terraform?  Currently, there is no support\nfor commits inside the Terraform ecosystem, so they have to be handled \nexternally.  Lack of finalizers are a known shortcoming \nfor Terraform and, once it is addressed, support for it can be added to the\nprovider.  In the mean time, we provide a golang script \nyou can use to fill the gap.",
            "title": "Commits"
        },
        {
            "location": "/comparison/#operational-commands",
            "text": "Ansible currently has a  panos_op  module allows users to run arbitrary\noperational commands.  An operational command could be something that just\nshows some part of the configuration, but it can also change configuration.\nSince Ansible doesn't store state, it doesn't care what the invocation of\nthe  panos_op  module results in.  This is a different story in Terraform.  The basic flow of Terraform is that\nthere is a read operation that determines if a create, update, or delete needs\nto take place.  But operational commands as a whole don't fit as neatly into\nthis paradigm.  What if the operational command is just a read?  What if the\noperational command makes a configuration change, and should only be executed\nonce?  This uncertainty is why support for operational commands in Terraform\nis not currently in place.",
            "title": "Operational Commands"
        },
        {
            "location": "/comparison/#facts-data-sources",
            "text": "Terraform may not have support for arbitrary operational commands, but it does\nhave a data source right now that you can retrieve specific parts of show system info  from the firewall or Panorama and then use that in your\nplan file.  This same thing is called \"facts\" in Ansible.  Some of our Ansible modules have\nsupport for an additional operation,  find , that acts in some ways like this,\nbut support for this is still being investigated or developed.",
            "title": "Facts / Data Sources"
        }
    ]
}