{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\nWelcome to the Terraform & Ansible Introduction lab!\n\n\nIn this lab we will deploy a VM-Series firewall in \nGoogle Cloud Platform\n (GCP) using Terraform.  Once deployed, we will then use \nTerraform\n and \nAnsible\n to manage the configuration of the firewall.  This will include hands-on definition of Terraform plans and Ansible playbooks while exploring the functionality of the Palo Alto Networks Ansible modules and Terraform provider.\n\n\nThe following are NOT goals of this lab:\n\n\n\n\n\n\nShow a realistic deployment of the firewall:\n More realistic deployment would only complicate the provisioning configuration. If you want to see a more realistic deployment of the firewall in GCP, then please refer to the links at the end of this document for examples.\n\n\n\n\n\n\nTeach Google Cloud Platform (GCP) functionality:\n The choice to use GCP for this lab was intended to provide exposure to GCP and its command line utilities.  However, a comprehensive overview of GCP is beyond the scope of this lab.  Many of the concept we'll briefly cover are similar to other public cloud providers.\n\n\n\n\n\n\nRequirements\n\n\n\n\nA laptop with Internet connectivity\n\n\nA standards-compliant web browser (Google Chrome recommended)\n\n\nProficiency with a Linux text editor (e.g., vim, nano, emacs, etc.)\n\n\n\n\nAbout This Lab\n\n\n\n\nQwiklabs:\n This lab is launched using Qwiklabs, which is an online learning environment that provides access to the actual environment you want to learn about, not a simulation or demo environment. Qwiklabs will establish a temporary account in Google Cloud Platform and create a new GCP project to use.  However, this lab may also be used outside of Qwiklabs if you have a have a \nGCP account\n.\n\n\nGoogle Cloud Shell:\n This lab makes use of the Google Cloud Shell instead of deploying a separate VM hosting the Terraform and Ansible packages. Cloud Shell is an interactive shell environment for Google Cloud Platform. It makes it easy for you to manage your projects and resources without having to install the Google Cloud SDK and other tools on a separate host. With Cloud Shell, the Cloud SDK gcloud command-line tool and other utilities you need are always available when you need them.\n\n\nGoogle Cloud SDK:\n The initial configuration of the lab environment utilizes the Google Cloud SDK command line interface to perform tasks such as enabling APIs and establishing credentials.  These tasks could just as easily be accomplished using the GCP web console.  However, familiarity with the CLI commands is useful and presents opportunities for further scripting and automation.",
            "title": "Introduction"
        },
        {
            "location": "/#introduction",
            "text": "Welcome to the Terraform & Ansible Introduction lab!  In this lab we will deploy a VM-Series firewall in  Google Cloud Platform  (GCP) using Terraform.  Once deployed, we will then use  Terraform  and  Ansible  to manage the configuration of the firewall.  This will include hands-on definition of Terraform plans and Ansible playbooks while exploring the functionality of the Palo Alto Networks Ansible modules and Terraform provider.  The following are NOT goals of this lab:    Show a realistic deployment of the firewall:  More realistic deployment would only complicate the provisioning configuration. If you want to see a more realistic deployment of the firewall in GCP, then please refer to the links at the end of this document for examples.    Teach Google Cloud Platform (GCP) functionality:  The choice to use GCP for this lab was intended to provide exposure to GCP and its command line utilities.  However, a comprehensive overview of GCP is beyond the scope of this lab.  Many of the concept we'll briefly cover are similar to other public cloud providers.",
            "title": "Introduction"
        },
        {
            "location": "/#requirements",
            "text": "A laptop with Internet connectivity  A standards-compliant web browser (Google Chrome recommended)  Proficiency with a Linux text editor (e.g., vim, nano, emacs, etc.)",
            "title": "Requirements"
        },
        {
            "location": "/#about-this-lab",
            "text": "Qwiklabs:  This lab is launched using Qwiklabs, which is an online learning environment that provides access to the actual environment you want to learn about, not a simulation or demo environment. Qwiklabs will establish a temporary account in Google Cloud Platform and create a new GCP project to use.  However, this lab may also be used outside of Qwiklabs if you have a have a  GCP account .  Google Cloud Shell:  This lab makes use of the Google Cloud Shell instead of deploying a separate VM hosting the Terraform and Ansible packages. Cloud Shell is an interactive shell environment for Google Cloud Platform. It makes it easy for you to manage your projects and resources without having to install the Google Cloud SDK and other tools on a separate host. With Cloud Shell, the Cloud SDK gcloud command-line tool and other utilities you need are always available when you need them.  Google Cloud SDK:  The initial configuration of the lab environment utilizes the Google Cloud SDK command line interface to perform tasks such as enabling APIs and establishing credentials.  These tasks could just as easily be accomplished using the GCP web console.  However, familiarity with the CLI commands is useful and presents opportunities for further scripting and automation.",
            "title": "About This Lab"
        },
        {
            "location": "/getting-started/",
            "text": "Getting Started\n\n\nIn this activity you will:\n\n\n\n\nLaunch the lab in Qwiklabs\n\n\nLaunch the Google Cloud Shell\n\n\n\n\n\n\nWARNING:\n You must use the credentials provided by Qwiklabs for this lab.  Failure to do so may result in charges to your personal Google account.  You should either log out of Google entirely before proceeding or open an Icognito window in the Google Chrome web browser.\n\n\n\n\n\n\nLog into Qwiklabs\n\n\nNavigate to the \nQwiklabs URL\n in your web browser\n\n\nhttps://paloaltonetworks.qwiklab.com\n\n\n\n\nLog in with your Qwiklabs credentials (sign up if you are new to Qwiklabs).\n\n\n\nLaunch the lab\n\n\nConfirm that the lab entitled \nIntroduction to Terraform and Ansible\n is listed under \nIn Progress\n on the welcome screen.\n\n\nClick on the \nIntroduction to Terraform and Ansible\n lab to add it to your \nMy Learning\n inventory.\n\n\n\nClick on the \nIntroduction to Terraform and Ansible\n lab in the \nMy Learning\n page.\n\n\n\nClick on \nStart Lab\n in the upper right corner of the main lab page.\n\n\n\nMake note of the \nUsername\n, \nPassword\n, and \nGCP Project ID\n fields that are generated.\n\n\n\nLog into Google Cloud Platform\n\n\nClick on the \nOpen Google Console\n button located under the \nConnection Details\n.  A new browser tab will open and take you to the Google login page.\n\n\nLog in using the credentials provided on the Qwiklabs launch page for this specific lab.\n\n\n\nClick \nAccept\n on the logon banner page to accept the Terms of Service.\n\n\n\nSince this is a temporary lab account you can skip adding account recovery options by clicking \nDone\n.\n\n\n\nSelect your country, opt out of email updates, and accept the updated Terms of Service and click \nAccept\n.\n\n\n\nLaunch Google Cloud Shell\n\n\nClick the menu icon in the upper left-hand corner of the Dashboard to hide the sidebar menu.\n\n\n\nIn the upper right-hand corner of the Dashboard, click on the Cloud Shell icon.\n\n\n\nA welcome page is displayed when launching the Cloud Shell for the first time. Click \nStart Cloud Shell\n to proceed.\n\n\n\nThe Cloud Shell will appear at the bottom of the Dashboard.  Wait a few moments as it provisions and connects to the environment.\n\n\n\nYou can click on the \nOpen in New Window\n icon in the Cloud Shell toolbar for a full-sized Cloud Shell display in a new browser tab.\n\n\n\nYou are now ready to proceed with the lab configuration.",
            "title": "Getting Started"
        },
        {
            "location": "/getting-started/#getting-started",
            "text": "In this activity you will:   Launch the lab in Qwiklabs  Launch the Google Cloud Shell    WARNING:  You must use the credentials provided by Qwiklabs for this lab.  Failure to do so may result in charges to your personal Google account.  You should either log out of Google entirely before proceeding or open an Icognito window in the Google Chrome web browser.",
            "title": "Getting Started"
        },
        {
            "location": "/getting-started/#log-into-qwiklabs",
            "text": "Navigate to the  Qwiklabs URL  in your web browser  https://paloaltonetworks.qwiklab.com  Log in with your Qwiklabs credentials (sign up if you are new to Qwiklabs).",
            "title": "Log into Qwiklabs"
        },
        {
            "location": "/getting-started/#launch-the-lab",
            "text": "Confirm that the lab entitled  Introduction to Terraform and Ansible  is listed under  In Progress  on the welcome screen.  Click on the  Introduction to Terraform and Ansible  lab to add it to your  My Learning  inventory.  Click on the  Introduction to Terraform and Ansible  lab in the  My Learning  page.  Click on  Start Lab  in the upper right corner of the main lab page.  Make note of the  Username ,  Password , and  GCP Project ID  fields that are generated.",
            "title": "Launch the lab"
        },
        {
            "location": "/getting-started/#log-into-google-cloud-platform",
            "text": "Click on the  Open Google Console  button located under the  Connection Details .  A new browser tab will open and take you to the Google login page.  Log in using the credentials provided on the Qwiklabs launch page for this specific lab.  Click  Accept  on the logon banner page to accept the Terms of Service.  Since this is a temporary lab account you can skip adding account recovery options by clicking  Done .  Select your country, opt out of email updates, and accept the updated Terms of Service and click  Accept .",
            "title": "Log into Google Cloud Platform"
        },
        {
            "location": "/getting-started/#launch-google-cloud-shell",
            "text": "Click the menu icon in the upper left-hand corner of the Dashboard to hide the sidebar menu.  In the upper right-hand corner of the Dashboard, click on the Cloud Shell icon.  A welcome page is displayed when launching the Cloud Shell for the first time. Click  Start Cloud Shell  to proceed.  The Cloud Shell will appear at the bottom of the Dashboard.  Wait a few moments as it provisions and connects to the environment.  You can click on the  Open in New Window  icon in the Cloud Shell toolbar for a full-sized Cloud Shell display in a new browser tab.  You are now ready to proceed with the lab configuration.",
            "title": "Launch Google Cloud Shell"
        },
        {
            "location": "/configuration/",
            "text": "Configuration\n\n\nIn this activity you will:\n\n\n\n\nInstall Terraform and Ansible\n\n\nConfigure the Google Cloud SDK\n\n\nEnable the Compute Engine API\n\n\nConfigure API credentials\n\n\nConfigure SSH credentials\n\n\n\n\n\n\nNOTE:\n  All of the commands listed within this activity should be executed within the Google Cloud Shell - \nnot on your laptop\n.\n\n\n\n\nInstall Terraform and Ansible\n\n\nDownload the lab repository to your home directory.\n\n\n$ git clone https://github.com/PaloAltoNetworks/terraform-ansible-intro\n\n\n\n\nChange into the lab directory and run the lab configuration script.  This will install the Terraform binary and the Ansible package.  This may take a few minutes to complete.\n\n\n$ cd terraform-ansible-intro\n$ ./setup\n\n\n\n\nRun the commands below to ensure the Terraform and Ansible binaries are properly installed.  Both executables should be located in the \n/usr/local/bin\n directory.\n\n\n$ terraform --version\n$ ansible --version\n\n\n\n\nEnable the Compute Engine API\n\n\nUse the following \ngcloud services\n command to enable the Compute Engine API.  This API will be used by Terraform to deploy the VM-Series instance.\n\n\n$ gcloud services enable compute.googleapis.com\n\n\n\n\nConfigure API credentials\n\n\nUse the following \ngcloud iam\n command to list the default service accounts.\n\n\n$ gcloud iam service-accounts list\n\n\n\n\nUse the following \ngcloud iam\n command to download the credentials for the \nCompute Engine default service account\n using its associated email address (displayed in the output of the previous command).\n\n\n$ gcloud iam service-accounts keys create gcp_compute_key.json --iam-account <EMAIL_ADDRESS>\n\n\n\n\nVerify the JSON credentials file was successfully created.\n\n\n$ cat gcp_compute_key.json\n\n\n\n\nConfigure SSH credentials\n\n\nCreate an SSH key with an empty passphrase and save it in the \n~/.ssh\n directory.\n\n\n$ ssh-keygen -t rsa -b 1024 -N '' -f ~/.ssh/sko19_ssh_key\n\n\n\n\nEnsure the file permissions for the SSH key are secure.\n\n\n$ chmod 400 ~/.ssh/sko19_ssh_key\n\n\n\n\n\n\nNOTE:\n GCP has the ability to manage all of its own SSH keys and propagate them automatically to projects and instances.  However, the VM-Series is only able to make use of a single SSH key.  Rather than leverage GCP's SSH key management process, we've created our own SSH key and configured the Compute Engine to use our key exclusively.  When we deploy the VM-Series in the next activity we'll instruct the instance to also use the SSH key we've created.",
            "title": "Configuration"
        },
        {
            "location": "/configuration/#configuration",
            "text": "In this activity you will:   Install Terraform and Ansible  Configure the Google Cloud SDK  Enable the Compute Engine API  Configure API credentials  Configure SSH credentials    NOTE:   All of the commands listed within this activity should be executed within the Google Cloud Shell -  not on your laptop .",
            "title": "Configuration"
        },
        {
            "location": "/configuration/#install-terraform-and-ansible",
            "text": "Download the lab repository to your home directory.  $ git clone https://github.com/PaloAltoNetworks/terraform-ansible-intro  Change into the lab directory and run the lab configuration script.  This will install the Terraform binary and the Ansible package.  This may take a few minutes to complete.  $ cd terraform-ansible-intro\n$ ./setup  Run the commands below to ensure the Terraform and Ansible binaries are properly installed.  Both executables should be located in the  /usr/local/bin  directory.  $ terraform --version\n$ ansible --version",
            "title": "Install Terraform and Ansible"
        },
        {
            "location": "/configuration/#enable-the-compute-engine-api",
            "text": "Use the following  gcloud services  command to enable the Compute Engine API.  This API will be used by Terraform to deploy the VM-Series instance.  $ gcloud services enable compute.googleapis.com",
            "title": "Enable the Compute Engine API"
        },
        {
            "location": "/configuration/#configure-api-credentials",
            "text": "Use the following  gcloud iam  command to list the default service accounts.  $ gcloud iam service-accounts list  Use the following  gcloud iam  command to download the credentials for the  Compute Engine default service account  using its associated email address (displayed in the output of the previous command).  $ gcloud iam service-accounts keys create gcp_compute_key.json --iam-account <EMAIL_ADDRESS>  Verify the JSON credentials file was successfully created.  $ cat gcp_compute_key.json",
            "title": "Configure API credentials"
        },
        {
            "location": "/configuration/#configure-ssh-credentials",
            "text": "Create an SSH key with an empty passphrase and save it in the  ~/.ssh  directory.  $ ssh-keygen -t rsa -b 1024 -N '' -f ~/.ssh/sko19_ssh_key  Ensure the file permissions for the SSH key are secure.  $ chmod 400 ~/.ssh/sko19_ssh_key   NOTE:  GCP has the ability to manage all of its own SSH keys and propagate them automatically to projects and instances.  However, the VM-Series is only able to make use of a single SSH key.  Rather than leverage GCP's SSH key management process, we've created our own SSH key and configured the Compute Engine to use our key exclusively.  When we deploy the VM-Series in the next activity we'll instruct the instance to also use the SSH key we've created.",
            "title": "Configure SSH credentials"
        },
        {
            "location": "/deployment/",
            "text": "Deployment\n\n\nIn this activity you will:\n\n\n\n\nDefine the Terraform plan variables\n\n\nInitialize the Terraform providers\n\n\nDeploy the VM-Series firewall\n\n\nUpdate the SSH configs\n\n\nSet the firewall administrative password\n\n\n\n\nDefine the Terraform plan variables\n\n\nChange into the \ndeployment\n directory.\n\n\n$ cd deployment\n\n\n\n\nEdit the file containing the Terraform variables.  These variable will be referenced in other Terraform plan files.\n\n\n$ vi gcp_variables.tf\n\n\n\n\nReplace the default value for the variable \ngcp_project_id\n with the GCP Project ID displayed in the Qwiklabs main page.  The \ngcp_region\n, \ngcp_credentials_file\n, and \ngcp_ssh_key\n variables have have been pre-populated.\n\n\nvariable \"gcp_project_id\" {\n  description = \"GCP Project ID\"\n  type = \"string\"\n  default = \"\"\n}\n\nvariable \"gcp_region\" {\n  description = \"Montr\u00e9al, Quebec GCP region\"\n  type = \"string\"\n  default = \"northamerica-northeast1\"\n}\n\nvariable \"gcp_credentials_file\" {\n  description = \"Full path to the JSON credentials file\"\n  type = \"string\"\n  default = \"../gcp_compute_key.json\"\n}\n\nvariable \"gcp_ssh_key\" {\n  description = \"Full path to the SSH public key file\"\n  type = \"string\"\n  default = \"../../.ssh/sko19_ssh_key.pub\"\n}\n\n\n\n\nSave the file and exit the text editor.\n\n\nInitialize the Terraform providers\n\n\nType the following command to initialize any Terraform providers specified in the plan files.\n\n\n$ terraform init\n\n\n\n\nDeploy the VM-Series firewall\n\n\nType the following command to perform a dry-run of the Terraform plan and gather its state data.\n\n\n$ terraform plan\n\n\n\n\nType the following command to execute the Terraform plan.  You can append \n--auto-approve\n to the command in order to avoid the confirmation step.\n\n\n$ terraform apply\n\n\n\n\nCopy and paste the output fields from the plan into a note or document on your laptop.  You will need this information later.\n\n\nUpdate the SSK config\n\n\nUse the following \ngcloud compute\n command to override the default GCP key management process and utilize our SSH key.\n\n\n$ gcloud compute config-ssh --ssh-key-file=~/.ssh/sko19_ssh_key\n\n\n\n\nSet the firewall administrator password\n\n\nUse the \ngcloud compute\n command to get the hostname of the VM-Series firewall instance.\n\n\n$ gcloud compute instances list\n\n\n\n\nSSH into the firewall using the fully qualified hostname of the instance.  You may need to wait a few moments for the firewall to finish booting up.\n\n\n$ ssh admin@<INSTANCE>.<ZONE>.<PROJECT>\n\n\n\n\n\n\nNOTE:\n If you receive a \nConnection refused\n response or are prompted for a password the VM-Series instance has not fully booted yet.  Hit \nControl-C\n and wait few moments before trying again.  Feel free to read the \nTerraform Bankground\n section to learn more about Terraform while you're waiting.\n\n\n\n\nOnce successfully logged in and presented with a CLI prompt you must set the administrative password for the VM-Series firewall.\n\n\nadmin@PA-VM> configure\nadmin@PA-VM# set mgt-config users admin password\nadmin@PA-VM# commit\nadmin@PA-VM# exit\nadmin@PA-VM> exit\n\n\n\n\nLaunch a separate web browser tab and log into the VM-Series web user interface using the external IP address displayed in the \nterraform apply\n output.\n\n\nYou are now ready to begin the Terraform portion of the lab.",
            "title": "Deployment"
        },
        {
            "location": "/deployment/#deployment",
            "text": "In this activity you will:   Define the Terraform plan variables  Initialize the Terraform providers  Deploy the VM-Series firewall  Update the SSH configs  Set the firewall administrative password",
            "title": "Deployment"
        },
        {
            "location": "/deployment/#define-the-terraform-plan-variables",
            "text": "Change into the  deployment  directory.  $ cd deployment  Edit the file containing the Terraform variables.  These variable will be referenced in other Terraform plan files.  $ vi gcp_variables.tf  Replace the default value for the variable  gcp_project_id  with the GCP Project ID displayed in the Qwiklabs main page.  The  gcp_region ,  gcp_credentials_file , and  gcp_ssh_key  variables have have been pre-populated.  variable \"gcp_project_id\" {\n  description = \"GCP Project ID\"\n  type = \"string\"\n  default = \"\"\n}\n\nvariable \"gcp_region\" {\n  description = \"Montr\u00e9al, Quebec GCP region\"\n  type = \"string\"\n  default = \"northamerica-northeast1\"\n}\n\nvariable \"gcp_credentials_file\" {\n  description = \"Full path to the JSON credentials file\"\n  type = \"string\"\n  default = \"../gcp_compute_key.json\"\n}\n\nvariable \"gcp_ssh_key\" {\n  description = \"Full path to the SSH public key file\"\n  type = \"string\"\n  default = \"../../.ssh/sko19_ssh_key.pub\"\n}  Save the file and exit the text editor.",
            "title": "Define the Terraform plan variables"
        },
        {
            "location": "/deployment/#initialize-the-terraform-providers",
            "text": "Type the following command to initialize any Terraform providers specified in the plan files.  $ terraform init",
            "title": "Initialize the Terraform providers"
        },
        {
            "location": "/deployment/#deploy-the-vm-series-firewall",
            "text": "Type the following command to perform a dry-run of the Terraform plan and gather its state data.  $ terraform plan  Type the following command to execute the Terraform plan.  You can append  --auto-approve  to the command in order to avoid the confirmation step.  $ terraform apply  Copy and paste the output fields from the plan into a note or document on your laptop.  You will need this information later.",
            "title": "Deploy the VM-Series firewall"
        },
        {
            "location": "/deployment/#update-the-ssk-config",
            "text": "Use the following  gcloud compute  command to override the default GCP key management process and utilize our SSH key.  $ gcloud compute config-ssh --ssh-key-file=~/.ssh/sko19_ssh_key",
            "title": "Update the SSK config"
        },
        {
            "location": "/deployment/#set-the-firewall-administrator-password",
            "text": "Use the  gcloud compute  command to get the hostname of the VM-Series firewall instance.  $ gcloud compute instances list  SSH into the firewall using the fully qualified hostname of the instance.  You may need to wait a few moments for the firewall to finish booting up.  $ ssh admin@<INSTANCE>.<ZONE>.<PROJECT>   NOTE:  If you receive a  Connection refused  response or are prompted for a password the VM-Series instance has not fully booted yet.  Hit  Control-C  and wait few moments before trying again.  Feel free to read the  Terraform Bankground  section to learn more about Terraform while you're waiting.   Once successfully logged in and presented with a CLI prompt you must set the administrative password for the VM-Series firewall.  admin@PA-VM> configure\nadmin@PA-VM# set mgt-config users admin password\nadmin@PA-VM# commit\nadmin@PA-VM# exit\nadmin@PA-VM> exit  Launch a separate web browser tab and log into the VM-Series web user interface using the external IP address displayed in the  terraform apply  output.  You are now ready to begin the Terraform portion of the lab.",
            "title": "Set the firewall administrator password"
        },
        {
            "location": "/terraform-background/",
            "text": "Terraform Background\n\n\nTerraform At a Glance\n\n\n\n\nCompany:  \nHashiCorp\n\n\nIntegration FCS: January 2018\n\n\nConfiguration: HCL (HashiCorp Configuration Language)\n\n\nDocumentation\n\n\nGitHub Repo\n\n\nImplementation Language: golang\n\n\n\n\nConfiguration Overview\n\n\nMany Files, One Configuration\n\n\nTerraform allows you to split your configuration into as many files as you\nwish.  Any Terraform file in the current working directory will be loaded and\nconcatenated with the others when you tell Terraform to apply your desired\nconfiguration.\n\n\nLocal State\n\n\nTerraform saves the things it has done to a local file, referred to as a\n\"state file\".  Because state is saved locally, that means that sometimes the\nlocal state will differ from what's actually configured on the firewall.\n\n\nThis is actually not a big deal, as many of Terraform's commands do a Read\noperation to check the actual state against what's saved locally.  Any\nchanges that are found are then saved to the local state automatically.\n\n\nExample Terraform Configuration\n\n\nHere's an example of a Terraform configuration file.  We will discuss the\nparts of this config below.\n\n\nvariable \"hostname\" {\n    default = \"127.0.0.1\"\n}\n\nvariable \"username\" {\n    default = \"admin\"\n}\n\nvariable \"password\" {\n    default = \"admin\"\n}\n\nprovider \"panos\" {\n    hostname = \"${var.hostname}\"\n    username = \"${var.username}\"\n    password = \"${var.password}\"\n}\n\nresource \"panos_management_profile\" \"ssh\" {\n    name = \"allow ssh\"\n    ssh = true\n}\n\nresource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    management_profile = \"${panos_management_profile.ssh.name}\"\n}\n\nresource \"panos_zone\" \"zone1\" {\n    name = \"L3-in\"\n    mode = \"layer3\"\n    interfaces = [\"ethernet1/1\"]\n    depends_on = [\"panos_ethernet_interface.eth1\"]\n}\n\n\n\n\nTerminology\n\n\nPlan\n\n\nA Terraform \nplan\n is the sum of all Terraform configuration files\nin a given directory.  These files are generally written in \nHCL\n.\n\n\nProvider\n\n\nA \nprovider\n can loosely thought of to be a product (such as the Palo Alto \nNetworks firewall) or a service (such as AWS, Azure, or GCP).  The provider \nunderstands the underlying API to the product or service, making individual \nparts of those things available as \nresources\n.\n\n\nMost providers require some kind of configuration in order to use.  For the\n\npanos\n provider, this is the authentication credentials of the firewall or\nPanorama that you want to configure.\n\n\nProviders are configured in a provider configuration block (e.g. -\n\nprovider \"panos\" {...}\n, and a plan can make use of any number of providers,\nall working together.\n\n\nResource\n\n\nA \nresource\n is an individual component that a provider supports \ncreate/read/update/delete operations for.\n\n\nFor the Palo Alto Networks firewall, this would be something like\nan ethernet interface, service object, or an interface management profile.\n\n\nData Source\n\n\nA \ndata source\n is like a resource, but read-only.\n\n\nFor example, the \npanos\n provider has\n\na data source\n\nthat gives you access to the results of \nshow system info\n.\n\n\nAttribute\n\n\nAn \nattribute\n is a single parameter that exists in either a resource or a \ndata source.  Individual attributes are specific to the resource itself, as to \nwhat type it is, if it's required or optional, has a default value, or if \nchanging it would require the whole resource to be recreated or not.\n\n\nAttributes can have a few different types:\n\n\n\n\nString\n:  \n\"foo\"\n, \n\"bar\"\n\n\nNumber\n: \n7\n, \n\"42\"\n (quoting numbers is fine in HCL)\n\n\nList\n: \n[\"item1\", \"item2\"]\n\n\nBoolean\n: \ntrue\n, \nfalse\n\n\nMap\n: \n{\"key\": \"value\"}\n (\nNote\n: some maps may have more complex values)\n\n\n\n\nVariables\n\n\nTerraform plans can have \nvariables\n to allow for more flexibility.  These \nvariables come in two flavors:  user variables and attribute variables.\n\nWhenever you want to use variables (or any other Terraform interpolation), \nyou'll be enclosing it in curly braces with a leading dollar sign:  \n\"${...}\"\n\n\nUser variables are variables that are defined in the Terraform plan file\nwith the \nvariable\n keyword.  These can be any of the types of values that\nattributes can be (default is string), and can also be configured to have\ndefault values.  When using a user variable in your plan files, they are\nreferenced with \nvar\n as a prefix: \n\"${var.hostname}\"\n.  Terraform looks for\nlocal variable values in the file \nterraform.tfvars\n.\n\n\nAttribute variables are variables that reference other resources or data\nsources within the same plan.  Specifying a resource attribute using an\nattribute variable creates an implicit dependency, covered below.\n\n\nDependencies\n\n\nThere are two ways to tell Terraform that resource \"A\" needs to be created\nbefore resource \"B\":  the universal \ndepends_on\n resource parameter or an\nattribute variable.  The first way, using \ndepends_on\n, is performed by\nadding the universal parameter \"depends_on\" within the dependent\nresource.  The second way, using attribute variables, is performed by\nreferencing a resource or data source attribute as a variable:\n\n\"${panos_management_profile.ssh.name}\"\n\n\nCommon Commands\n\n\nThe Terraform binary has many different CLI arguments that it supports.  We'll\ndiscuss only a few of them here:\n\n\n$ terraform init\n\n\n\n\nterraform init\n initializes the current directory based off of the local plan files, \ndownloading any missing provider binaries.\n\n\n$ terraform plan\n\n\n\n\nterraform plan\n refreshes provider/resource states and reports what changes \nneed to take place.\n\n\n$ terraform apply\n\n\n\n\nterraform apply\n refreshes provider/resource states and makes any needed \nchanges to the resources.\n\n\n$ terraform destroy\n\n\n\n\nterraform destroy\n refreshes provider/resource states and removes all \nresources that Terraform created.",
            "title": "Background"
        },
        {
            "location": "/terraform-background/#terraform-background",
            "text": "",
            "title": "Terraform Background"
        },
        {
            "location": "/terraform-background/#terraform-at-a-glance",
            "text": "Company:   HashiCorp  Integration FCS: January 2018  Configuration: HCL (HashiCorp Configuration Language)  Documentation  GitHub Repo  Implementation Language: golang",
            "title": "Terraform At a Glance"
        },
        {
            "location": "/terraform-background/#configuration-overview",
            "text": "",
            "title": "Configuration Overview"
        },
        {
            "location": "/terraform-background/#many-files-one-configuration",
            "text": "Terraform allows you to split your configuration into as many files as you\nwish.  Any Terraform file in the current working directory will be loaded and\nconcatenated with the others when you tell Terraform to apply your desired\nconfiguration.",
            "title": "Many Files, One Configuration"
        },
        {
            "location": "/terraform-background/#local-state",
            "text": "Terraform saves the things it has done to a local file, referred to as a\n\"state file\".  Because state is saved locally, that means that sometimes the\nlocal state will differ from what's actually configured on the firewall.  This is actually not a big deal, as many of Terraform's commands do a Read\noperation to check the actual state against what's saved locally.  Any\nchanges that are found are then saved to the local state automatically.",
            "title": "Local State"
        },
        {
            "location": "/terraform-background/#example-terraform-configuration",
            "text": "Here's an example of a Terraform configuration file.  We will discuss the\nparts of this config below.  variable \"hostname\" {\n    default = \"127.0.0.1\"\n}\n\nvariable \"username\" {\n    default = \"admin\"\n}\n\nvariable \"password\" {\n    default = \"admin\"\n}\n\nprovider \"panos\" {\n    hostname = \"${var.hostname}\"\n    username = \"${var.username}\"\n    password = \"${var.password}\"\n}\n\nresource \"panos_management_profile\" \"ssh\" {\n    name = \"allow ssh\"\n    ssh = true\n}\n\nresource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    management_profile = \"${panos_management_profile.ssh.name}\"\n}\n\nresource \"panos_zone\" \"zone1\" {\n    name = \"L3-in\"\n    mode = \"layer3\"\n    interfaces = [\"ethernet1/1\"]\n    depends_on = [\"panos_ethernet_interface.eth1\"]\n}",
            "title": "Example Terraform Configuration"
        },
        {
            "location": "/terraform-background/#terminology",
            "text": "",
            "title": "Terminology"
        },
        {
            "location": "/terraform-background/#plan",
            "text": "A Terraform  plan  is the sum of all Terraform configuration files\nin a given directory.  These files are generally written in  HCL .",
            "title": "Plan"
        },
        {
            "location": "/terraform-background/#provider",
            "text": "A  provider  can loosely thought of to be a product (such as the Palo Alto \nNetworks firewall) or a service (such as AWS, Azure, or GCP).  The provider \nunderstands the underlying API to the product or service, making individual \nparts of those things available as  resources .  Most providers require some kind of configuration in order to use.  For the panos  provider, this is the authentication credentials of the firewall or\nPanorama that you want to configure.  Providers are configured in a provider configuration block (e.g. - provider \"panos\" {...} , and a plan can make use of any number of providers,\nall working together.",
            "title": "Provider"
        },
        {
            "location": "/terraform-background/#resource",
            "text": "A  resource  is an individual component that a provider supports \ncreate/read/update/delete operations for.  For the Palo Alto Networks firewall, this would be something like\nan ethernet interface, service object, or an interface management profile.",
            "title": "Resource"
        },
        {
            "location": "/terraform-background/#data-source",
            "text": "A  data source  is like a resource, but read-only.  For example, the  panos  provider has a data source \nthat gives you access to the results of  show system info .",
            "title": "Data Source"
        },
        {
            "location": "/terraform-background/#attribute",
            "text": "An  attribute  is a single parameter that exists in either a resource or a \ndata source.  Individual attributes are specific to the resource itself, as to \nwhat type it is, if it's required or optional, has a default value, or if \nchanging it would require the whole resource to be recreated or not.  Attributes can have a few different types:   String :   \"foo\" ,  \"bar\"  Number :  7 ,  \"42\"  (quoting numbers is fine in HCL)  List :  [\"item1\", \"item2\"]  Boolean :  true ,  false  Map :  {\"key\": \"value\"}  ( Note : some maps may have more complex values)",
            "title": "Attribute"
        },
        {
            "location": "/terraform-background/#variables",
            "text": "Terraform plans can have  variables  to allow for more flexibility.  These \nvariables come in two flavors:  user variables and attribute variables. \nWhenever you want to use variables (or any other Terraform interpolation), \nyou'll be enclosing it in curly braces with a leading dollar sign:   \"${...}\"  User variables are variables that are defined in the Terraform plan file\nwith the  variable  keyword.  These can be any of the types of values that\nattributes can be (default is string), and can also be configured to have\ndefault values.  When using a user variable in your plan files, they are\nreferenced with  var  as a prefix:  \"${var.hostname}\" .  Terraform looks for\nlocal variable values in the file  terraform.tfvars .  Attribute variables are variables that reference other resources or data\nsources within the same plan.  Specifying a resource attribute using an\nattribute variable creates an implicit dependency, covered below.",
            "title": "Variables"
        },
        {
            "location": "/terraform-background/#dependencies",
            "text": "There are two ways to tell Terraform that resource \"A\" needs to be created\nbefore resource \"B\":  the universal  depends_on  resource parameter or an\nattribute variable.  The first way, using  depends_on , is performed by\nadding the universal parameter \"depends_on\" within the dependent\nresource.  The second way, using attribute variables, is performed by\nreferencing a resource or data source attribute as a variable: \"${panos_management_profile.ssh.name}\"",
            "title": "Dependencies"
        },
        {
            "location": "/terraform-background/#common-commands",
            "text": "The Terraform binary has many different CLI arguments that it supports.  We'll\ndiscuss only a few of them here:  $ terraform init  terraform init  initializes the current directory based off of the local plan files, \ndownloading any missing provider binaries.  $ terraform plan  terraform plan  refreshes provider/resource states and reports what changes \nneed to take place.  $ terraform apply  terraform apply  refreshes provider/resource states and makes any needed \nchanges to the resources.  $ terraform destroy  terraform destroy  refreshes provider/resource states and removes all \nresources that Terraform created.",
            "title": "Common Commands"
        },
        {
            "location": "/terraform-lab/",
            "text": "Terraform Lab Activities\n\n\nIn this activity you will:\n\n\n\n\nPerform basic network configuration\n\n\nCreate objects and security rules\n\n\nClean up the firewall configs\n\n\n\n\nTask 1 - Basic Networking Config\n\n\nChange into the \nterraform\n directory.  We'll use it for all of our Terraform files.\n\n\n$ cd ../terraform\n\n\n\n\nOpen the file \npanos_variables.tf\n in a text editor such as \nvim\n, \nemacs\n, or \nnano\n and replace the default values of the varaibles \npanos_hostname\n, \npanos_username\n, and \npanos_password\n with the appropriate values from your VM-Series instance.\n\n\nvariable \"panos_hostname\" {\n  description = \"Hostname of the VM-Series instance\"\n  type = \"string\"\n  default = \"\"\n}\n\nvariable \"panos_username\" {\n  description = \"Username of the VM-Series administrator\"\n  type = \"string\"\n  default = \"northamerica-northeast1\"\n}\n\nvariable \"panos_password\" {\n  description = \"Password of the VM-Series administrator\"\n  type = \"string\"\n  default = \"\"\n}\n\n\n\n\nUsing your text editor create the file \npanos_plan.tf\n.  We will place our Terraform plan in this file.\n\n\nStart by defining the provider config, which will use the \npanos\n provider. Note that the hostname, username, and password fields refer to the variables we defined in the \npanos_variables.tf\n file.\n\n\nprovider \"panos\" {\n    hostname = \"${var.panos_hostname}\"\n    username = \"${var.panos_username}\"\n    password = \"${var.panos_password}\"\n}\n\n\n\n\nNetwork Interfaces\n\n\nNext, create the interfaces.  Here are screenshots of the interfaces we need to create:\n\n\n\n\n\n\nAdd the following configuration to \npanos_plan.tf\n.  Note that the \nethernet1/2\n interface omits the option to create the default route via DHCP.\n\n\nresource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    create_dhcp_default_route = true\n}\n\nresource \"panos_ethernet_interface\" \"eth2\" {\n    name = \"ethernet1/2\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n}\n\n\n\n\nRefer to the \nprovider documentation\n for ethernet interfaces for more info if you need.\n\n\nZones\n\n\nNext, create zones for the interfaces we just added.  Here are screenshots of the zones we need to create:\n\n\n\n\n\n\nAdd the following configuration to \npanos_plan.tf\n.  The interfaces are referenced by name, so that Terraform automatically knows that the interfaces need to be created before the zones themselves.\n\n\nresource \"panos_zone\" \"int\" {\n    name = \"L3-trust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth1.name}\"]\n}\n\nresource \"panos_zone\" \"ext\" {\n    name = \"L3-untrust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth2.name}\"]\n}\n\n\n\n\nRefer to the \nprovider\ndocumentation\n for zones if you need.\n\n\nApply the Terraform Plan\n\n\nYour final, full \npanos_plan.tf\n file should look something like this:\n\n\nprovider \"panos\" {\n    hostname = \"127.0.0.1\"\n    username = \"admin\"\n    password = \"admin\"\n}\n\nresource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    create_dhcp_default_route = true\n}\n\nresource \"panos_ethernet_interface\" \"eth2\" {\n    name = \"ethernet1/2\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n}\n\nresource \"panos_zone\" \"int\" {\n    name = \"L3-trust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth1.name}\"]\n}\n\nresource \"panos_zone\" \"ext\" {\n    name = \"L3-untrust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth2.name}\"]\n}\n\n\n\n\nLet's apply the config to our firewall.  You need to run \nterraform init\n first to download all the providers we need, and then check your config with \nterraform plan\n:\n\n\n$ terraform init\n$ terraform plan\n\n\n\n\nIf there are no errors, go ahead and push your config updates the firewall:\n\n\n$ terraform apply\n\n\n\n\nLog in to the GUI of your firewall and verify that the configuration matches what you want.  Note that because of the way Terraform currently functions, the changes have only been made to the candidate configuration and have \nnot\n been committed.\n\n\n\n\nTask 2 - Objects and Security Rule Creation\n\n\nNext, we will create an address object and some security rules. Here is a screenshot of an address object we need to create:\n\n\n\n\nAdd the following to \npanos_plan.tf\n:\n\n\nresource \"panos_address_object\" \"wp\" {\n    name = \"wordpress server\"\n    description = \"Internal server\"\n    value = \"10.1.23.45\"\n}\n\n\n\n\nRefer to the \nprovider documentation\n for address objects if you need.\n\n\nNow, here is a screenshot of security rules that we need to create:\n\n\n\n\nAdd the following to \npanos_plan.tf\n.  Just like with the networking config, zones and objects are referenced by name, so that Terraform knows they need to be created before our security rules.\n\n\nresource \"panos_security_rule_group\" \"policy\" {\n    rule {\n        name = \"Wordpress Traffic\"\n        source_zones = [\"${panos_zone.ext.name}\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"${panos_zone.int.name}\"]\n        destination_addresses = [\"any\"]\n        applications = [\"web-browsing\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"allow\"\n    }\n    rule {\n        name = \"Outbound\"\n        source_zones = [\"${panos_zone.int.name}\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"${panos_zone.ext.name}\"]\n        destination_addresses = [\"any\"]\n        applications = [\"any\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"allow\"\n    }\n    rule {\n        name = \"Default Deny\"\n        source_zones = [\"any\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"any\"]\n        destination_addresses = [\"any\"]\n        applications = [\"any\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"deny\"\n    }\n}\n\n\n\n\nApply the Terraform Plan\n\n\nLet's apply the config to our firewall.  We don't need to run \nterraform init\n again, so just check your config with \nterraform plan\n:\n\n\n$ terraform plan\n\n\n\n\nIf there are no errors, go ahead and push your config updates the firewall:\n\n\n$ terraform apply\n\n\n\n\nLog in to the GUI of your firewall and verify that the configuration matches what you want.  Again, the changes have only been made to the candidate configuration and have \nnot\n been committed.\n\n\n\n\nTask 3 - Cleanup\n\n\nTerraform will clean up our config for us with the \nterraform destroy\n command. Run it to prepare for the Ansible portion of the lab:\n\n\n$ terraform destroy\n\n\n\n\nYou're done with the Terraform portion of the lab.",
            "title": "Lab Activities"
        },
        {
            "location": "/terraform-lab/#terraform-lab-activities",
            "text": "In this activity you will:   Perform basic network configuration  Create objects and security rules  Clean up the firewall configs",
            "title": "Terraform Lab Activities"
        },
        {
            "location": "/terraform-lab/#task-1-basic-networking-config",
            "text": "Change into the  terraform  directory.  We'll use it for all of our Terraform files.  $ cd ../terraform  Open the file  panos_variables.tf  in a text editor such as  vim ,  emacs , or  nano  and replace the default values of the varaibles  panos_hostname ,  panos_username , and  panos_password  with the appropriate values from your VM-Series instance.  variable \"panos_hostname\" {\n  description = \"Hostname of the VM-Series instance\"\n  type = \"string\"\n  default = \"\"\n}\n\nvariable \"panos_username\" {\n  description = \"Username of the VM-Series administrator\"\n  type = \"string\"\n  default = \"northamerica-northeast1\"\n}\n\nvariable \"panos_password\" {\n  description = \"Password of the VM-Series administrator\"\n  type = \"string\"\n  default = \"\"\n}  Using your text editor create the file  panos_plan.tf .  We will place our Terraform plan in this file.  Start by defining the provider config, which will use the  panos  provider. Note that the hostname, username, and password fields refer to the variables we defined in the  panos_variables.tf  file.  provider \"panos\" {\n    hostname = \"${var.panos_hostname}\"\n    username = \"${var.panos_username}\"\n    password = \"${var.panos_password}\"\n}",
            "title": "Task 1 - Basic Networking Config"
        },
        {
            "location": "/terraform-lab/#network-interfaces",
            "text": "Next, create the interfaces.  Here are screenshots of the interfaces we need to create:    Add the following configuration to  panos_plan.tf .  Note that the  ethernet1/2  interface omits the option to create the default route via DHCP.  resource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    create_dhcp_default_route = true\n}\n\nresource \"panos_ethernet_interface\" \"eth2\" {\n    name = \"ethernet1/2\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n}  Refer to the  provider documentation  for ethernet interfaces for more info if you need.",
            "title": "Network Interfaces"
        },
        {
            "location": "/terraform-lab/#zones",
            "text": "Next, create zones for the interfaces we just added.  Here are screenshots of the zones we need to create:    Add the following configuration to  panos_plan.tf .  The interfaces are referenced by name, so that Terraform automatically knows that the interfaces need to be created before the zones themselves.  resource \"panos_zone\" \"int\" {\n    name = \"L3-trust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth1.name}\"]\n}\n\nresource \"panos_zone\" \"ext\" {\n    name = \"L3-untrust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth2.name}\"]\n}  Refer to the  provider\ndocumentation  for zones if you need.",
            "title": "Zones"
        },
        {
            "location": "/terraform-lab/#apply-the-terraform-plan",
            "text": "Your final, full  panos_plan.tf  file should look something like this:  provider \"panos\" {\n    hostname = \"127.0.0.1\"\n    username = \"admin\"\n    password = \"admin\"\n}\n\nresource \"panos_ethernet_interface\" \"eth1\" {\n    name = \"ethernet1/1\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n    create_dhcp_default_route = true\n}\n\nresource \"panos_ethernet_interface\" \"eth2\" {\n    name = \"ethernet1/2\"\n    vsys = \"vsys1\"\n    mode = \"layer3\"\n    enable_dhcp = true\n}\n\nresource \"panos_zone\" \"int\" {\n    name = \"L3-trust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth1.name}\"]\n}\n\nresource \"panos_zone\" \"ext\" {\n    name = \"L3-untrust\"\n    mode = \"layer3\"\n    interfaces = [\"${panos_ethernet_interface.eth2.name}\"]\n}  Let's apply the config to our firewall.  You need to run  terraform init  first to download all the providers we need, and then check your config with  terraform plan :  $ terraform init\n$ terraform plan  If there are no errors, go ahead and push your config updates the firewall:  $ terraform apply  Log in to the GUI of your firewall and verify that the configuration matches what you want.  Note that because of the way Terraform currently functions, the changes have only been made to the candidate configuration and have  not  been committed.",
            "title": "Apply the Terraform Plan"
        },
        {
            "location": "/terraform-lab/#task-2-objects-and-security-rule-creation",
            "text": "Next, we will create an address object and some security rules. Here is a screenshot of an address object we need to create:   Add the following to  panos_plan.tf :  resource \"panos_address_object\" \"wp\" {\n    name = \"wordpress server\"\n    description = \"Internal server\"\n    value = \"10.1.23.45\"\n}  Refer to the  provider documentation  for address objects if you need.  Now, here is a screenshot of security rules that we need to create:   Add the following to  panos_plan.tf .  Just like with the networking config, zones and objects are referenced by name, so that Terraform knows they need to be created before our security rules.  resource \"panos_security_rule_group\" \"policy\" {\n    rule {\n        name = \"Wordpress Traffic\"\n        source_zones = [\"${panos_zone.ext.name}\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"${panos_zone.int.name}\"]\n        destination_addresses = [\"any\"]\n        applications = [\"web-browsing\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"allow\"\n    }\n    rule {\n        name = \"Outbound\"\n        source_zones = [\"${panos_zone.int.name}\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"${panos_zone.ext.name}\"]\n        destination_addresses = [\"any\"]\n        applications = [\"any\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"allow\"\n    }\n    rule {\n        name = \"Default Deny\"\n        source_zones = [\"any\"]\n        source_addresses = [\"any\"]\n        source_users = [\"any\"]\n        hip_profiles = [\"any\"]\n        destination_zones = [\"any\"]\n        destination_addresses = [\"any\"]\n        applications = [\"any\"]\n        services = [\"application-default\"]\n        categories = [\"any\"]\n        action = \"deny\"\n    }\n}",
            "title": "Task 2 - Objects and Security Rule Creation"
        },
        {
            "location": "/terraform-lab/#apply-the-terraform-plan_1",
            "text": "Let's apply the config to our firewall.  We don't need to run  terraform init  again, so just check your config with  terraform plan :  $ terraform plan  If there are no errors, go ahead and push your config updates the firewall:  $ terraform apply  Log in to the GUI of your firewall and verify that the configuration matches what you want.  Again, the changes have only been made to the candidate configuration and have  not  been committed.",
            "title": "Apply the Terraform Plan"
        },
        {
            "location": "/terraform-lab/#task-3-cleanup",
            "text": "Terraform will clean up our config for us with the  terraform destroy  command. Run it to prepare for the Ansible portion of the lab:  $ terraform destroy  You're done with the Terraform portion of the lab.",
            "title": "Task 3 - Cleanup"
        },
        {
            "location": "/ansible-background/",
            "text": "Ansible Background\n\n\nAnsible At a Glance\n\n\n\n\nCompany: \nRedHat\n\n\nIntegration FCS: January 2015\n\n\nConfiguration: YAML (Yet Another Markup Language)\n\n\nDocumentation\n\n\nGitHub Repo\n\n\nImplementation Language: python\n\n\n\n\nConfiguration Overview\n\n\nPlaybooks\n\n\nThough Ansible allows you to execute ad hoc commands against your desired\ninventory, the better way to use Ansible is with Ansible playbooks. \nAnsible playbooks are a list of configuration operations, or plays, to be\nperformed.  Ansible playbooks are written in YAML, which you can find out\nmore about\n\nhere\n. \nPlaybooks are run from top to bottom, which means that if one configuration\ndepends on another being present, you simply put the dependency higher in the\nplaybook.  You can even tell Ansible to run another playbook from within the\nfirst playbook by importing it in.\n\n\nNo Local State\n\n\nUnlike Terraform, Ansible does not keep a local state of what is configured.\n\n\nModules Are Use Case Focused\n\n\nAlso unlike the Terraform provider, Ansible modules tend to be more use case\nfocused as opposed to trying to be a single, atomic component controller.  The\n\npanos_interface\n\nmodule is probably the best example of this to date, as it not only creates\ninterfaces, but can also create zones, place the interface into that zone,\nthen finally put the interface into a virtual router.  That same workflow in\nTerraform would require three separate resources using dependencies.\n\n\nExample Ansible Configuration\n\n\nHere's an example of an Ansible playbook.  We will discuss the various\nparts of this below.\n\n\n- name: My Ansible Playbook\n  hosts: my-fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n  - name: \"Add interface management profile\"\n    panos_management_profile:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      name: 'allow ssh'\n      ssh: true\n      commit: false\n\n  - name: \"Configure eth1/1 and put it in zone L3-in\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      zone_name: 'L3-in'\n      commit: false\n\n\n\n\nTerminology\n\n\nHosts\n\n\nAnsible executes actions against an inventory.  If you\u2019re going to run Ansible \nin production, you\u2019ll probably want to use the inventory file to organize your \nfirewalls and Panoramas into groups to make management easier.  For the \npurposes of our lab, however, we just want to run the playbooks against a \nsingle host.  So instead of putting the host in a hosts file, we\u2019re going to \nuse variables instead.\n\n\nIf you desire, you can read more about Ansible inventory\n\nhere\n.\n\n\nConnection\n\n\nTypically Ansible will ssh to a remote machine and perform commands as the \nspecified user account.  However, we don't want this for the Palo Alto Networks \nAnsible modules, as the modules connect to our API.  Thus this should be set to \n\"local\" as we want Ansible to initiate the connection locally.\n\n\nGather Facts\n\n\nAnsible facts are just information about remote nodes.  In our case, we aren\u2019t \ngoing to use facts for anything, so we\u2019re disabling them to ensure that our \nAnsible invocations are run in a timely manner (this is would probably not be \ndisabled in production).\n\n\nIf you want to read more about facts, you can find that info\n\nhere\n.\n\n\nRoles\n\n\nLet\u2019s discuss the \"PaloAltoNetworks.paloaltonetworks\" role that our playbook \nis using.  Ansible comes with various Palo Alto Networks packages when you \n\npip install ansible\n, but updating these packages takes a lot of time and \neffort.  In an effort to get new features to customers sooner, we've made \nnewer features available as an Ansible galaxy role.  Including this role in \nour playbook means that Ansible will use the role\u2019s code (the newest released \ncode) for the Ansible plays instead of the older code that's merged upstream \nwith Ansible.\n\n\nTasks\n\n\nEach playbook contains a list of tasks to perform.  These are executed in \norder, one at a time against the inventory.  Each task will have a \"name\", \nand this name is what shows up on the CLI when executing the Ansible playbook.\nBesides the name, you will specify the module to execute, and then an \nindented list of the values you want to pass in to that module.\n\n\nKnowing what you know about tasks, let\u2019s take a look at that \"include_vars\"\ntask.  At this point, knowing what the format of tasks is, you can now\nidentify \"include_vars\" as a module invocation (documentation for\n\"include_vars\" is\n\nhere\n). \n\n\nSo what\u2019s that \nno_log\n part?  This is simply to keep the authentication\ncredentials safe without compromising the verbosity of our Ansible output. \nYou can read more about that\n\nhere\n\nin the Ansible FAQs.\n\n\nDependencies\n\n\nAs mentioned previously, if you're using Ansible playbooks, then when you\nhave dependencies, simply place those further up in the playbook.",
            "title": "Background"
        },
        {
            "location": "/ansible-background/#ansible-background",
            "text": "",
            "title": "Ansible Background"
        },
        {
            "location": "/ansible-background/#ansible-at-a-glance",
            "text": "Company:  RedHat  Integration FCS: January 2015  Configuration: YAML (Yet Another Markup Language)  Documentation  GitHub Repo  Implementation Language: python",
            "title": "Ansible At a Glance"
        },
        {
            "location": "/ansible-background/#configuration-overview",
            "text": "",
            "title": "Configuration Overview"
        },
        {
            "location": "/ansible-background/#playbooks",
            "text": "Though Ansible allows you to execute ad hoc commands against your desired\ninventory, the better way to use Ansible is with Ansible playbooks. \nAnsible playbooks are a list of configuration operations, or plays, to be\nperformed.  Ansible playbooks are written in YAML, which you can find out\nmore about here . \nPlaybooks are run from top to bottom, which means that if one configuration\ndepends on another being present, you simply put the dependency higher in the\nplaybook.  You can even tell Ansible to run another playbook from within the\nfirst playbook by importing it in.",
            "title": "Playbooks"
        },
        {
            "location": "/ansible-background/#no-local-state",
            "text": "Unlike Terraform, Ansible does not keep a local state of what is configured.",
            "title": "No Local State"
        },
        {
            "location": "/ansible-background/#modules-are-use-case-focused",
            "text": "Also unlike the Terraform provider, Ansible modules tend to be more use case\nfocused as opposed to trying to be a single, atomic component controller.  The panos_interface \nmodule is probably the best example of this to date, as it not only creates\ninterfaces, but can also create zones, place the interface into that zone,\nthen finally put the interface into a virtual router.  That same workflow in\nTerraform would require three separate resources using dependencies.",
            "title": "Modules Are Use Case Focused"
        },
        {
            "location": "/ansible-background/#example-ansible-configuration",
            "text": "Here's an example of an Ansible playbook.  We will discuss the various\nparts of this below.  - name: My Ansible Playbook\n  hosts: my-fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_creds.yml'\n    no_log: 'yes'\n\n  - name: \"Add interface management profile\"\n    panos_management_profile:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      name: 'allow ssh'\n      ssh: true\n      commit: false\n\n  - name: \"Configure eth1/1 and put it in zone L3-in\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      zone_name: 'L3-in'\n      commit: false",
            "title": "Example Ansible Configuration"
        },
        {
            "location": "/ansible-background/#terminology",
            "text": "",
            "title": "Terminology"
        },
        {
            "location": "/ansible-background/#hosts",
            "text": "Ansible executes actions against an inventory.  If you\u2019re going to run Ansible \nin production, you\u2019ll probably want to use the inventory file to organize your \nfirewalls and Panoramas into groups to make management easier.  For the \npurposes of our lab, however, we just want to run the playbooks against a \nsingle host.  So instead of putting the host in a hosts file, we\u2019re going to \nuse variables instead.  If you desire, you can read more about Ansible inventory here .",
            "title": "Hosts"
        },
        {
            "location": "/ansible-background/#connection",
            "text": "Typically Ansible will ssh to a remote machine and perform commands as the \nspecified user account.  However, we don't want this for the Palo Alto Networks \nAnsible modules, as the modules connect to our API.  Thus this should be set to \n\"local\" as we want Ansible to initiate the connection locally.",
            "title": "Connection"
        },
        {
            "location": "/ansible-background/#gather-facts",
            "text": "Ansible facts are just information about remote nodes.  In our case, we aren\u2019t \ngoing to use facts for anything, so we\u2019re disabling them to ensure that our \nAnsible invocations are run in a timely manner (this is would probably not be \ndisabled in production).  If you want to read more about facts, you can find that info here .",
            "title": "Gather Facts"
        },
        {
            "location": "/ansible-background/#roles",
            "text": "Let\u2019s discuss the \"PaloAltoNetworks.paloaltonetworks\" role that our playbook \nis using.  Ansible comes with various Palo Alto Networks packages when you  pip install ansible , but updating these packages takes a lot of time and \neffort.  In an effort to get new features to customers sooner, we've made \nnewer features available as an Ansible galaxy role.  Including this role in \nour playbook means that Ansible will use the role\u2019s code (the newest released \ncode) for the Ansible plays instead of the older code that's merged upstream \nwith Ansible.",
            "title": "Roles"
        },
        {
            "location": "/ansible-background/#tasks",
            "text": "Each playbook contains a list of tasks to perform.  These are executed in \norder, one at a time against the inventory.  Each task will have a \"name\", \nand this name is what shows up on the CLI when executing the Ansible playbook.\nBesides the name, you will specify the module to execute, and then an \nindented list of the values you want to pass in to that module.  Knowing what you know about tasks, let\u2019s take a look at that \"include_vars\"\ntask.  At this point, knowing what the format of tasks is, you can now\nidentify \"include_vars\" as a module invocation (documentation for\n\"include_vars\" is here ).   So what\u2019s that  no_log  part?  This is simply to keep the authentication\ncredentials safe without compromising the verbosity of our Ansible output. \nYou can read more about that here \nin the Ansible FAQs.",
            "title": "Tasks"
        },
        {
            "location": "/ansible-background/#dependencies",
            "text": "As mentioned previously, if you're using Ansible playbooks, then when you\nhave dependencies, simply place those further up in the playbook.",
            "title": "Dependencies"
        },
        {
            "location": "/ansible-lab/",
            "text": "Ansible Lab Activities\n\n\nIn this activity you will:\n\n\n\n\nSet up the initial configuration files\n\n\nPerform basic network configuration\n\n\nCreate objects and security rules\n\n\n\n\nTask 1 - Lab Setup\n\n\nChange into the \nansible\n directory.  We'll use it for all of our Ansible files.\n\n\n$ cd ../ansible\n\n\n\n\nThen, install the Palo Alto Networks Ansible Galaxy role:\n\n\n$ sudo ansible-galaxy install PaloAltoNetworks.paloaltonetworks\n\n\n\n\n\n\nTask 2 - Basic Network Config\n\n\nUsing a text editor such as \nvim\n, \nemacs\n, or \nnano\n edit the file called \ninventory\n.  This file will contains a list of hosts that Ansible will communicate with during execution.\n\n\nReplace the value \n127.0.0.1\n with the external IP address of your VM-Series instance.\n\n\n[fw]\n127.0.0.1\n\n\n\n\nNext, create the file \nfw_vars.yml\n and add the following valiables.  Fill in the blanks with the appropriate values from your VM-Series instance.\n\n\nip_address: ''\nusername: ''\npassword: ''\n\n\n\n\nNow, create the file \nnetwork.yml\n.  This will be the playbook that holds the low level networking config for our firewall.\n\n\nEach playbook needs the following header information to pull in the variables we just defined.  Add the following to \nnetwork.yml\n:\n\n\n- name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_vars.yml'\n    no_log: 'yes'\n\n\n\n\nNetwork Interfaces & Zones\n\n\nWe're going to create the exact same configuration with Ansible as we did with Terraform.  Here are screenshots of the network interfaces and zones we need to create:\n\n\n\n\n\n\n\n\n\n\nAdd the following to \nnetwork.yml\n:\n\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_vars.yml'\n    no_log: 'yes'\n\n  - name: \"Configure eth1/1\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      create_default_route: true\n      zone_name: 'L3-trust'\n      commit: False\n\n  - name: \"Configure eth1/2\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/2'\n      zone_name: 'L3-untrust'\n      commit: False\n\n\n\n\nRefer to the \nmodule\ndocumentation\n\nfor ethernet interfaces if you need.\n\n\nNote that Ansible is a little different from Terraform.  We have to specify the \nip_address\n, \nusername\n, and \npassword\n each time because each module executes independently.  Also, we don't have to create the zones as a separate step because they will be created for us if they don't exist.\n\n\nRun the Playbook\n\n\nYour final, full \nnetwork.yml\n playbook should look like this:\n\n\n- name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_vars.yml'\n    no_log: 'yes'\n\n  - name: \"Configure eth1/1\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      create_default_route: true\n      zone_name: 'L3-trust'\n      commit: False\n\n  - name: \"Configure eth1/2\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/2'\n      zone_name: 'L3-untrust'\n      commit: False\n\n\n\n\nRun your playbook with the following command:\n\n\n$ ansible-playbook -i inventory network.yml\n\n\n\n\nLog in to the GUI of your firewall and verify that the configuration matches what you want.  Because we specified \ncommit: False\n for each module call in our playbook, the changes have only been made to the candidate configuration and have \nnot\n been committed.\n\n\nIf you get errors, indentation is most likely the problem.  Once you fix any errors, run the playbook again and the firewall should now have your desired config.\n\n\n\n\nTask 3 - Objects and Security Rule Creation\n\n\nNow we will create the same address object and security rules as in the Terraform portion.  Create a new file \nrules.yml\n, and copy in the header information from the network config steps:\n\n\n- name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_vars.yml'\n    no_log: 'yes'\n\n\n\n\nHere is the address object we need to create:\n\n\n\n\nAdd the following to \nrules.yml\n:\n\n\n  - name: \"Add address object for wordpress server\"\n    panos_object:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      addressobject: 'wordpress server'\n      address: '10.1.23.45'\n      description: 'Internal server'\n      commit: false\n\n\n\n\nRefer to the \nmodule\ndocumentation\n\nfor address objects if you need.\n\n\nHere are the security rules we need to create:\n\n\n\n\nAdd the following to \nrules.yml\n:\n\n\n  - name: \"Add Wordpress Traffic rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Wordpress Traffic'\n      source_zone: ['L3-untrust']\n      destination_zone: ['L3-trust']\n      destination_ip: ['wordpress server']\n      application: ['web-browsing']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Outbound rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Outbound'\n      source_zone: ['L3-trust']\n      destination_zone: ['L3-untrust']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Default Deny rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Default Deny'\n      action: 'deny'\n      commit: false\n\n\n\n\nRun the Playbook\n\n\nYour final, full \nrules.yml\n playbook should look like this:\n\n\n- name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_vars.yml'\n    no_log: 'yes'\n\n  - name: \"Add address object for wordpress server\"\n    panos_object:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      addressobject: 'wordpress server'\n      address: '10.1.23.45'\n      description: 'Internal server'\n      commit: false\n\n  - name: \"Add Wordpress Traffic rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Wordpress Traffic'\n      source_zone: ['L3-untrust']\n      destination_zone: ['L3-trust']\n      destination_ip: ['wordpress server']\n      application: ['web-browsing']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Outbound rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Outbound'\n      source_zone: ['L3-trust']\n      destination_zone: ['L3-untrust']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Default Deny rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Default Deny'\n      action: 'deny'\n      commit: false\n\n\n\n\nRun your playbook with the following command:\n\n\n$ ansible-playbook -i inventory rules.yml\n\n\n\n\nLog in to the GUI of your firewall and verify that the configuration matches what you want.  Remember that your changes haven't been committed, and if you get errors, indentation is most likely the problem.\n\n\nYou're done with the Ansible portion of the lab.",
            "title": "Lab Activities"
        },
        {
            "location": "/ansible-lab/#ansible-lab-activities",
            "text": "In this activity you will:   Set up the initial configuration files  Perform basic network configuration  Create objects and security rules",
            "title": "Ansible Lab Activities"
        },
        {
            "location": "/ansible-lab/#task-1-lab-setup",
            "text": "Change into the  ansible  directory.  We'll use it for all of our Ansible files.  $ cd ../ansible  Then, install the Palo Alto Networks Ansible Galaxy role:  $ sudo ansible-galaxy install PaloAltoNetworks.paloaltonetworks",
            "title": "Task 1 - Lab Setup"
        },
        {
            "location": "/ansible-lab/#task-2-basic-network-config",
            "text": "Using a text editor such as  vim ,  emacs , or  nano  edit the file called  inventory .  This file will contains a list of hosts that Ansible will communicate with during execution.  Replace the value  127.0.0.1  with the external IP address of your VM-Series instance.  [fw]\n127.0.0.1  Next, create the file  fw_vars.yml  and add the following valiables.  Fill in the blanks with the appropriate values from your VM-Series instance.  ip_address: ''\nusername: ''\npassword: ''  Now, create the file  network.yml .  This will be the playbook that holds the low level networking config for our firewall.  Each playbook needs the following header information to pull in the variables we just defined.  Add the following to  network.yml :  - name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_vars.yml'\n    no_log: 'yes'",
            "title": "Task 2 - Basic Network Config"
        },
        {
            "location": "/ansible-lab/#network-interfaces-zones",
            "text": "We're going to create the exact same configuration with Ansible as we did with Terraform.  Here are screenshots of the network interfaces and zones we need to create:      Add the following to  network.yml :    tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_vars.yml'\n    no_log: 'yes'\n\n  - name: \"Configure eth1/1\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      create_default_route: true\n      zone_name: 'L3-trust'\n      commit: False\n\n  - name: \"Configure eth1/2\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/2'\n      zone_name: 'L3-untrust'\n      commit: False  Refer to the  module\ndocumentation \nfor ethernet interfaces if you need.  Note that Ansible is a little different from Terraform.  We have to specify the  ip_address ,  username , and  password  each time because each module executes independently.  Also, we don't have to create the zones as a separate step because they will be created for us if they don't exist.",
            "title": "Network Interfaces &amp; Zones"
        },
        {
            "location": "/ansible-lab/#run-the-playbook",
            "text": "Your final, full  network.yml  playbook should look like this:  - name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_vars.yml'\n    no_log: 'yes'\n\n  - name: \"Configure eth1/1\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/1'\n      create_default_route: true\n      zone_name: 'L3-trust'\n      commit: False\n\n  - name: \"Configure eth1/2\"\n    panos_interface:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      if_name: 'ethernet1/2'\n      zone_name: 'L3-untrust'\n      commit: False  Run your playbook with the following command:  $ ansible-playbook -i inventory network.yml  Log in to the GUI of your firewall and verify that the configuration matches what you want.  Because we specified  commit: False  for each module call in our playbook, the changes have only been made to the candidate configuration and have  not  been committed.  If you get errors, indentation is most likely the problem.  Once you fix any errors, run the playbook again and the firewall should now have your desired config.",
            "title": "Run the Playbook"
        },
        {
            "location": "/ansible-lab/#task-3-objects-and-security-rule-creation",
            "text": "Now we will create the same address object and security rules as in the Terraform portion.  Create a new file  rules.yml , and copy in the header information from the network config steps:  - name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_vars.yml'\n    no_log: 'yes'  Here is the address object we need to create:   Add the following to  rules.yml :    - name: \"Add address object for wordpress server\"\n    panos_object:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      addressobject: 'wordpress server'\n      address: '10.1.23.45'\n      description: 'Internal server'\n      commit: false  Refer to the  module\ndocumentation \nfor address objects if you need.  Here are the security rules we need to create:   Add the following to  rules.yml :    - name: \"Add Wordpress Traffic rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Wordpress Traffic'\n      source_zone: ['L3-untrust']\n      destination_zone: ['L3-trust']\n      destination_ip: ['wordpress server']\n      application: ['web-browsing']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Outbound rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Outbound'\n      source_zone: ['L3-trust']\n      destination_zone: ['L3-untrust']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Default Deny rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Default Deny'\n      action: 'deny'\n      commit: false",
            "title": "Task 3 - Objects and Security Rule Creation"
        },
        {
            "location": "/ansible-lab/#run-the-playbook_1",
            "text": "Your final, full  rules.yml  playbook should look like this:  - name: SKO2019 Ansible Playbook\n  hosts: fw\n  connection: local\n  gather_facts: false\n\n  roles:\n    - role: PaloAltoNetworks.paloaltonetworks\n\n  tasks:\n  - name: Grab auth creds\n    include_vars: 'fw_vars.yml'\n    no_log: 'yes'\n\n  - name: \"Add address object for wordpress server\"\n    panos_object:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      addressobject: 'wordpress server'\n      address: '10.1.23.45'\n      description: 'Internal server'\n      commit: false\n\n  - name: \"Add Wordpress Traffic rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Wordpress Traffic'\n      source_zone: ['L3-untrust']\n      destination_zone: ['L3-trust']\n      destination_ip: ['wordpress server']\n      application: ['web-browsing']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Outbound rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Outbound'\n      source_zone: ['L3-trust']\n      destination_zone: ['L3-untrust']\n      action: 'allow'\n      commit: false\n\n  - name: \"Add Default Deny rule\"\n    panos_security_rule:\n      ip_address: '{{ ip_address }}'\n      username: '{{ username }}'\n      password: '{{ password }}'\n      operation: 'add'\n      rule_name: 'Default Deny'\n      action: 'deny'\n      commit: false  Run your playbook with the following command:  $ ansible-playbook -i inventory rules.yml  Log in to the GUI of your firewall and verify that the configuration matches what you want.  Remember that your changes haven't been committed, and if you get errors, indentation is most likely the problem.  You're done with the Ansible portion of the lab.",
            "title": "Run the Playbook"
        },
        {
            "location": "/clean-up/",
            "text": "Clean Up\n\n\nIn this activity you will:\n\n\n\n\nDestroy the deployment\n\n\n\n\nDestroy the Deployment\n\n\nWhen deploying infrastructure in the public cloud it is important to tear it down when it is no longer needed.  Otherwise you will end up paying for services that are no longer needed.\n\n\nChange into the \ndeployment\n directory.\n\n\n$ cd ../deployment\n\n\n\n\nTell Terraform to destroy the contents of its plan files.\n\n\n$ terraform destroy\n\n\n\n\n\n\nNOTE:\n Qwiklabs would normally handle this for you once the lab is completed but the process is illustrated here as a helpful reminder.",
            "title": "Clean Up"
        },
        {
            "location": "/clean-up/#clean-up",
            "text": "In this activity you will:   Destroy the deployment",
            "title": "Clean Up"
        },
        {
            "location": "/clean-up/#destroy-the-deployment",
            "text": "When deploying infrastructure in the public cloud it is important to tear it down when it is no longer needed.  Otherwise you will end up paying for services that are no longer needed.  Change into the  deployment  directory.  $ cd ../deployment  Tell Terraform to destroy the contents of its plan files.  $ terraform destroy   NOTE:  Qwiklabs would normally handle this for you once the lab is completed but the process is illustrated here as a helpful reminder.",
            "title": "Destroy the Deployment"
        },
        {
            "location": "/comparison/",
            "text": "Comparing Terraform and Ansible\n\n\nAt this point, you've now used both Ansible and Terraform to configure a\nPalo Alto Networks firewall.  Though you've used these two tools to deploy\nthe same configuration, they differ in some important ways.  Let's discuss\nsome of those differences now.\n\n\nReputation\n\n\nBoth tools have a certain reputation associated with them.  Terraform is known\nmore for its power in deployment, while Ansible is known more for its\nflexibility in configuration.  Both products can do both jobs just fine.\n\n\nRegardless of their reputations, the most important part is that Palo Alto Networks\nhas integrations with both, and either way will get the job done.  It's\njust a matter of preference.\n\n\nIdempotence\n\n\nBoth Terraform and Ansible support \nidempotent\n\noperations.  Saying that an operation is idempotent means that applying it\nmultiple times will not change the result.  This is important for automation\ntools because they can be run to change configuration \nand\n also to verify\nthat the configuration actually matches what you want.  You can run\n\nterraform apply\n continuously for hours, and if your configuration matches\nwhat is defined in the plan, it won't actually change anything.\n\n\nHowever, the Palo Alto Networks Ansible modules do not currently support\nidempotent operation.  Most of the modules have an \noperation\n field which\ncan be \nadd\n, \nupdate\n or \ndelete\n.  Running the same playbook over again will\ncause a failure, because you can't add objects over top of themselves, or\ndelete ones that don't exist.  Supporting idempotent operations will be added\nto these modules in the future.\n\n\nCommits\n\n\nAs you've probably noticed, a lot of the Ansible modules allow you to commit\ndirectly from them.  There is also a dedicated Ansible module that just does\ncommits, containing support for both the firewall and Panorama.\n\n\nSo how do you perform commits with Terraform?  Currently, there is no support\nfor commits inside the Terraform ecosystem, so they have to be handled\nexternally.  Lack of finalizers are\n\na known shortcoming\n\nfor Terraform and, once it is addressed, support for it can be added to the\nprovider.  In the mean time, we provide\n\na golang script\n\nyou can use to fill the gap.\n\n\nOperational Commands\n\n\nAnsible currently has a \npanos_op\n module allows users to run arbitrary\noperational commands.  An operational command could be something that just\nshows some part of the configuration, but it can also change configuration.\nSince Ansible doesn't store state, it doesn't care what the invocation of\nthe \npanos_op\n module results in.\n\n\nThis is a different story in Terraform.  The basic flow of Terraform is that\nthere is a read operation that determines if a create, update, or delete needs\nto take place.  But operational commands as a whole don't fit as neatly into\nthis paradigm.  What if the operational command is just a read?  What if the\noperational command makes a configuration change, and should only be executed\nonce?  This uncertainty is why support for operational commands in Terraform\nis not currently in place.\n\n\nFacts / Data Sources\n\n\nTerraform may not have support for arbitrary operational commands, but it does\nhave a data source right now that you can retrieve specific parts of\n\nshow system info\n from the firewall or Panorama and then use that in your\nplan file.\n\n\nThis same thing is called \"facts\" in Ansible.  Some of our Ansible modules have\nsupport for an additional operation, \nfind\n, that acts in some ways like this,\nbut support for this is still being investigated or developed.\n\n\nFurther Reading\n\n\n\n\n\n\nTerraform\n\n\n\n\n\n\nTerraform Documentation\n\n\n\n\n\n\nTerraform panos Provider\n\n\n\n\n\n\nTerraform: Up & Running\n\n\n\n\n\n\n\n\n\n\nAnsible\n\n\n\n\n\n\nAnsible Docs\n\n\n\n\n\n\nansible-pan\n\n\n\n\n\n\nAnsible: Up & Running",
            "title": "Conclusion"
        },
        {
            "location": "/comparison/#comparing-terraform-and-ansible",
            "text": "At this point, you've now used both Ansible and Terraform to configure a\nPalo Alto Networks firewall.  Though you've used these two tools to deploy\nthe same configuration, they differ in some important ways.  Let's discuss\nsome of those differences now.",
            "title": "Comparing Terraform and Ansible"
        },
        {
            "location": "/comparison/#reputation",
            "text": "Both tools have a certain reputation associated with them.  Terraform is known\nmore for its power in deployment, while Ansible is known more for its\nflexibility in configuration.  Both products can do both jobs just fine.  Regardless of their reputations, the most important part is that Palo Alto Networks\nhas integrations with both, and either way will get the job done.  It's\njust a matter of preference.",
            "title": "Reputation"
        },
        {
            "location": "/comparison/#idempotence",
            "text": "Both Terraform and Ansible support  idempotent \noperations.  Saying that an operation is idempotent means that applying it\nmultiple times will not change the result.  This is important for automation\ntools because they can be run to change configuration  and  also to verify\nthat the configuration actually matches what you want.  You can run terraform apply  continuously for hours, and if your configuration matches\nwhat is defined in the plan, it won't actually change anything.  However, the Palo Alto Networks Ansible modules do not currently support\nidempotent operation.  Most of the modules have an  operation  field which\ncan be  add ,  update  or  delete .  Running the same playbook over again will\ncause a failure, because you can't add objects over top of themselves, or\ndelete ones that don't exist.  Supporting idempotent operations will be added\nto these modules in the future.",
            "title": "Idempotence"
        },
        {
            "location": "/comparison/#commits",
            "text": "As you've probably noticed, a lot of the Ansible modules allow you to commit\ndirectly from them.  There is also a dedicated Ansible module that just does\ncommits, containing support for both the firewall and Panorama.  So how do you perform commits with Terraform?  Currently, there is no support\nfor commits inside the Terraform ecosystem, so they have to be handled\nexternally.  Lack of finalizers are a known shortcoming \nfor Terraform and, once it is addressed, support for it can be added to the\nprovider.  In the mean time, we provide a golang script \nyou can use to fill the gap.",
            "title": "Commits"
        },
        {
            "location": "/comparison/#operational-commands",
            "text": "Ansible currently has a  panos_op  module allows users to run arbitrary\noperational commands.  An operational command could be something that just\nshows some part of the configuration, but it can also change configuration.\nSince Ansible doesn't store state, it doesn't care what the invocation of\nthe  panos_op  module results in.  This is a different story in Terraform.  The basic flow of Terraform is that\nthere is a read operation that determines if a create, update, or delete needs\nto take place.  But operational commands as a whole don't fit as neatly into\nthis paradigm.  What if the operational command is just a read?  What if the\noperational command makes a configuration change, and should only be executed\nonce?  This uncertainty is why support for operational commands in Terraform\nis not currently in place.",
            "title": "Operational Commands"
        },
        {
            "location": "/comparison/#facts-data-sources",
            "text": "Terraform may not have support for arbitrary operational commands, but it does\nhave a data source right now that you can retrieve specific parts of show system info  from the firewall or Panorama and then use that in your\nplan file.  This same thing is called \"facts\" in Ansible.  Some of our Ansible modules have\nsupport for an additional operation,  find , that acts in some ways like this,\nbut support for this is still being investigated or developed.",
            "title": "Facts / Data Sources"
        },
        {
            "location": "/comparison/#further-reading",
            "text": "Terraform    Terraform Documentation    Terraform panos Provider    Terraform: Up & Running      Ansible    Ansible Docs    ansible-pan    Ansible: Up & Running",
            "title": "Further Reading"
        }
    ]
}